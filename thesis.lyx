#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass llncs
\begin_preamble
\usepackage{graphicx}
\graphicspath{{.//}}
\end_preamble
\options final
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics pdftex
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Optimizing Storage of Energy Event Data in In-Memory Databases"
\pdf_author "Leonhard Schweizer"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Optimizing Storage of Energy Event Data in In-Memory Databases
\end_layout

\begin_layout Author
Leonhard Schweizer
\end_layout

\begin_layout Institute
Hasso Plattner Institute
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
email{leonhard.schweizer@student.hpi.uni-potsdam.de}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
In the course of the ongoing implementation of smart metering in Germany,
 residential customers alone will produce roughly 1.4 trillion records per
 year through their power meters.
 In other words, energy providers will have to deal with 1.4GB of raw data
 every 15 minutes, which is the default measurement interval of modern metering
 devices.
 The processing of continuous data streams of this dimension is a big challenge
 today and traditional OLAP systems aren't capable of analysing this huge
 amount of data in real-time.
 Thus, energy event data is sent to the providers at most once per day and
 analytical possibilities remain unused.
 By chosing an in-memory database as storage the data can be processed and
 analyzed simultaneously while notably reducing the amount of required space
 at the same time through the utilization of compression potentials in column-ba
sed tables.
 As a result, new opportunities arise, like offering electricity rates with
 real-time pricing or managing supply and demand based on up-to-the-minute
 analytics.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Not only the power market of Germany, but also those of other European countries
 are undergoing radical changes these days.
\end_layout

\begin_layout Standard
On the one hand, the growing importance of renewable and distributed energy
 sources like wind and solar energy as part of the aimed-at energy turnaround
 leads to an increased need of information.
 Despite their unpredictable nature, utility companies will depend on detailed
 insight into [large concentrated power plants, ATP]
\end_layout

\begin_layout Standard
On the other hand, the deregulation of markets forces suppliers of electric
 energy to offer competitive contract conditions and new tariff models to
 their customers.
 Amongst others, possibilities include contracts with very low or even no
 terms, encouraging the consumers to change their providers more frequently.
 On top of that, [RTP, TOUB]
\end_layout

\begin_layout Standard
[Daten von Smart Metern, Energieerzeugern]
\end_layout

\begin_layout Standard
[Herausforderungen: Verarbeitung, Speicherung, Analyse]
\end_layout

\begin_layout Standard
[Bogen schlagen zu In Memory, column stores]
\end_layout

\begin_layout Section
[AMI und Simulation]
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:AMI"

\end_inset

[
\begin_inset Quotes eld
\end_inset

Tatsächliche
\begin_inset Quotes erd
\end_inset

 Architektur]
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/ami.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The Advanced Metering Infrastrucutre as depicted in 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/lcn/SchapranowKZP10"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
[Simulation -> 
\begin_inset Quotes eld
\end_inset

Implementation
\begin_inset Quotes erd
\end_inset

]
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abweichungen zu 2.1 (MDUS), DB als Bottleneck
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As an extensive rollout of smart metering devices and the corresponding
 metering infrastructure (cf.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:AMI"

\end_inset

) hasn't taken place yet in Germany, a simulation had to be used to generate
 a constant event stream of significant scale.
 Since the generated data should not only be used for stress testing, but
 also for real time analyses and visualization, various requirements had
 to be met by the simulation system.
\end_layout

\begin_layout Standard
The system had to be capable to simulate at least 100 million smart meters,
 each initiating one reading event per 15 minutes.
 Furthermore, the number of simulated metering devices should be freely
 configurable.
 On the one hand, the system thereby can be used to simulate divergent numbers
 of customers for energy providers of different size.
 On the other hand, the system can be used to simulate the projected total
 amount of events in the future smart grid of Germany.
\end_layout

\begin_layout Standard
In avoidance of unfavorable and advantageous effects of random data, for
 instance on compression rates, and with regard to data analysis and visualizati
on tests, the generated readings should be based on real power consumption
 data.
 Furthermore, the simulation should be aware of single customers.
 That means that for a given customer id, reading events should occur in
 15 minute intervals approximately.
 Besides, the unity of all readings of any simulated customer should form
 a realistic consumption behaviour over extended periods of time, e.g.
 days, weeks, months and years.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Bisher keine Rede von 
\begin_inset Quotes eld
\end_inset

customern
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to meet these requirements, the simulation system has been split
 up into three components, which are depicted in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/data-simulator.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Simulation"

\end_inset

Components of the AMI simulation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Data-Producer"

\end_inset

Data Producer
\end_layout

\begin_layout Standard
An instance of the data producer, which is implemented as Java executable,
 represents any number of smart meters.
 One instance of the data producer can connect to exactly one concentrator
 (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Concentrator"

\end_inset

).
 A dedicated, persistent TCP/IP connection is built between the data producer
 and a concentrator for each thread the data producer is spawning.
 Thereby, one thread simulates up to XYZ smart meters.
 Thus, the number of smart meters that can be simulated by a single instance
 is mostly limited by the number of threads the host system is capable to
 handle and the network capacity.
\end_layout

\begin_layout Standard
The data producer expects two main input parameters: An initial timestamp,
 which defaults to the current local time, and a standard load profile,
 which defaults to the H0 profile published by the BDEW
\begin_inset Foot
status open

\begin_layout Plain Layout
German Energy and Water Association
\end_layout

\end_inset

.
 Such profiles contain the average consumption of a specific customer base
 (which are residential customers in the case of the H0 profile) over a
 period of one or more years.
 They consist of counter readings or consumption deltas in 15 minute intervals,
 yielding 35040 values for non-leapyears.
 For reasons depicted in Sect.
 4.3
\begin_inset Note Note
status open

\begin_layout Plain Layout
Querverweis!
\end_layout

\end_inset

, we prefer consumption deltas over counter readings.
\end_layout

\begin_layout Standard
Based on these two input parameters, readings are generated.
 The initial timestamp is used to calculate the current simulated day and
 time.
 After that, the according consumption value is read from the standard load
 profile.
 A random variance is added to this value 
\begin_inset Formula $v$
\end_inset

 for every generated reading 
\begin_inset Formula $r_{\mathrm{{v}}}$
\end_inset

 such that 
\begin_inset Formula $v-0,2\cdot v\leq r_{\mathrm{{v}}}\leq v+0,2\cdot v$
\end_inset

.
 Furthermore, the timestamp of the generated reading is rounded down to
 15 minute intervals.
 For instance, 13:14:55 would be replaced by 13:00:00 (cf.
 4.3
\begin_inset Note Note
status open

\begin_layout Plain Layout
Querverweis!
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
The third and last component of a reading is the unique integer device id
 by which every simulated smart meter can be identified.
 In our scenario, this device id is equivalent to a customer id, since relocatio
ns and the like aren't relevant for us.
\end_layout

\begin_layout Standard
The data producer generates discrete reading events for each of these identifier
s every 15 minutes and sends them to the assigned concentrator instantly.
 Thereby, the identifiers are spread randomly accross the 15 minute intervall,
 but keep their time slot across multiple intervals as long as the simulation
 is running.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

 shows one hour of readings for a given smart meter, starting at Sat, 28
 May 2011 20:00:00 GMT.
 During this hour, the household associated with the smart meter carrying
 the device id 32202775 had a total consumption of 0,143kWh.
\end_layout

\begin_layout Standard
Since we execute the simulation over an ethernet network via TCP/IP, data
 loss is of no concern.
 Thus, the push architecture described here could be favored over the pull
 approach which dominates in real world metering infrastructures.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Sample-readings"

\end_inset

Sample readings generated by the data producer
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle" tabularwidth="60col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Smart Meter ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value [Wh]
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306612800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306613700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306614600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306615500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Concentrator"

\end_inset

Concentrator
\end_layout

\begin_layout Standard
Just like the data producer, the concentrator is implemented as Java executable.
 Its purpose is to aggregate events and to forward these aggregated batches
 to a database client (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Database-Client"

\end_inset

), thus reducing the number of connections and insert events visible to
 the central database system.
\end_layout

\begin_layout Standard
A concentrator accepts any number of TCP/IP connections from any number
 of data producers (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-Producer"

\end_inset

).
 In turn, the concentrator can connect to one or more database clients,
 again via TCP/IP.
 The primary reason for supporting multiple database clients is the evaluation
 of distributed database systems, which is the subject of another thesis
\begin_inset Note Note
status open

\begin_layout Plain Layout
Verweis
\end_layout

\end_inset

.
 In this case, the concentrator is provided with the data partitioning instructi
ons and forwards the readings to the proper destination database instance.
\end_layout

\begin_layout Standard
The concentrator collects incoming readings until the batch size reaches
 a configurable threshold (default: 60000 readings) or the oldest reading
 in the batch exceeds a certain age (default: 5 minutes).
 Once this happens, the batch of readings gets converted into a column-wise
 fashion and is sent to the corresponding database client together with
 the number of readings contained in the batch.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Concentrator-Output"

\end_inset

 illustrates this conversion with the aid of the first two records of the
 row based data shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

.
 into a column based format, which is beneficial for inserting data into
 column based tables.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/row-data.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/column-data.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Concentrator-Output"

\end_inset

The first two records from Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

 in row format and formated as output of a concentrator
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to the reasons outlined in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-Producer"

\end_inset

, the push approach could again be favored over a polling based architecture.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Database-Client"

\end_inset

Database Client
\end_layout

\begin_layout Subsubsection
Database
\end_layout

\begin_layout Section
[(Insert) Performance]
\end_layout

\begin_layout Itemize
Was bringt Insert Only / Verzicht auf Keys, warum kein Problem
\end_layout

\begin_layout Itemize
Was bringt Verzicht auf Logs
\end_layout

\begin_layout Itemize
Was bringt Verzicht auf Autocommit
\end_layout

\begin_layout Itemize
Messbarer Unterschied Insert Float / Int?
\end_layout

\begin_layout Itemize
Select / Aggregation?
\end_layout

\begin_layout Section
Compression
\end_layout

\begin_layout Subsection
[Heavy -vs Lightweight?]
\end_layout

\begin_layout Subsection
Lightweight Column Compression Techniques
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Einteilung / Überblick, Verweis auf Bit Compression, Variable Byte Coding,
 PFOR -> nicht Gegenstand der Betrachtung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Domain Coding
\end_layout

\begin_layout Standard
Domain coding or dictionary compression is the fundamental compression algorithm
 which is utilized regardless of data types and structures and independently
 from other compression algorithms.
 All original values of a column are stored in a sorted dictionary and the
 column itself is represented as index vector consisting of ordinal references
 to this dictionary.
 Thus, a column containing 
\begin_inset Formula $d$
\end_inset

 distinct values of an arbitrary type and a total of 
\begin_inset Formula $t$
\end_inset

 values can be represented with 
\begin_inset Formula 
\begin{equation}
t\cdot\lceil\log_{2}(d)\rceil
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits optimally.
 The size of the dictionary itself has to be added to the total amount of
 required main memory, which carries weight especially when the record set
 contains a high percentage of distinct values.
 
\end_layout

\begin_layout Standard
Aside from the reduction of memory consumption, this method also entails
 an acceleration of processing speed due to the handling of smaller data
 volumes on a per request basis and the optimization of processing units
 for ordinal types on the hardware layer.
\end_layout

\begin_layout Subsubsection
Prefix Coding
\end_layout

\begin_layout Standard
Prefix coding is powerful in such cases where a column contains one specific
 value very often (e.g.
 the NULL-value) and the table can be sorted by this column such that this
 value occurs at the beginning of this column.
 The prefix of equal values is then removed from the index vector completely.
 The prefix value and the number of occurrences are saved separately, each
 with a consumption of 32 bits.
 A column with a total of 
\begin_inset Formula $t$
\end_inset

 elements, 
\begin_inset Formula $d$
\end_inset

 distinct values and a prefix of 
\begin_inset Formula $p$
\end_inset

 elements thus can be compressed to 
\begin_inset Formula 
\begin{equation}
(t-p)\cdot\lceil\log_{2}(d)\rceil+64
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
\end_layout

\begin_layout Subsubsection
Sparse Coding
\end_layout

\begin_layout Standard
If the occurences of the most frequent value are spread throughout a column,
 sparse coding can be used to reduce the size of this column.
 In doing so, all occurences of the value are removed from the index vector
 and this socalled sparse value is saved once as reference into the dictionary,
 consuming 32 bits.
 A bit vector is generated for the column, indicating whether the value
 corresponding to the element at the given index equals the sparse value
 or not.
 Thus, sparse compression reduces the size of a column with 
\begin_inset Formula $s$
\end_inset

 occurences of the sparse value to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
(t-s)\cdot\lceil\log_{2}(d)\rceil+t+32
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
 In addition, a prefix coding could be applied to the bit vector.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abweichung vom zitierten Paper!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To retrieve a value from a sparse encoded column, the bit vector has to
 be checked at the given index.
 If it indicates that the value differs from the sparse value, the index
 of the actual value within the index vector can be retrieved through the
 number of set bits up to the given index.
\end_layout

\begin_layout Subsubsection
Cluster Coding
\end_layout

\begin_layout Standard
When applying cluster coding, the index vector gets divided into equally
 sized blocks.
 All blocks which contain only one distinct value are then compressed by
 removing all but one occurence of the value within this block from the
 index vector.
 In addition, a bit vector is generated which indicates whether a block
 has been compressed or not.
 Therefore, cluster coding is applicable in cases where a column contains
 only few distinct values which form blocks innately.
 For instance, a column containing the alternating values 1, 2 and 3 would
 be the worst case for cluster coding.
 In the best case, a column with a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values could be compressed to 
\begin_inset Formula 
\begin{equation}
\frac{t}{b}\cdot\lceil\log_{2}(d)\rceil+\frac{t}{b}
\end{equation}

\end_inset

bits, where 
\begin_inset Formula $b$
\end_inset

 is the block size and 
\begin_inset Formula $b\mid t$
\end_inset

.
\end_layout

\begin_layout Standard
To retrieve the value of a given index 
\begin_inset Formula $i$
\end_inset

, the corresponding block has to be determined first by calculating 
\begin_inset Formula $\lfloor\frac{i}{b}\rfloor$
\end_inset

.
 The actual position within the index vector then can be determined by calculati
ng 
\begin_inset Formula $i-c\cdot(b-1)$
\end_inset

,
\begin_inset Note Note
status open

\begin_layout Plain Layout
Corner Cases überprüfen!
\end_layout

\end_inset

 where 
\begin_inset Formula $c$
\end_inset

 is the number of set bits in the bit vector up to the corresponding block.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Komplizierte Erklärung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Indirect Coding
\end_layout

\begin_layout Standard
Just like cluster coding, indirect coding is based on a division of the
 index vector into blocks of equal size.
 However, a domain coding of these blocks takes place.
 Thus, every block can have its own dictionary as additional level of indirectio
n between the actual value stored in the global dictionary and the bit vector
 pointing to this value from the index vector.
 Sharing dictionaries among subsequent blocks is possible as long as adding
 new values to the dictionary wouldn't increase the size of the bit vector
 representing the key.
 Furthermore, blocks with a high percentage of distinct values still can
 use the global dictionary directly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Datenstrukturen, Dekodierung?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Such beeing the case, indirect coding is particularly powerful in columns
 which contain blocks with few distinct values.
\end_layout

\begin_layout Subsubsection
Run Length Encoding
\end_layout

\begin_layout Standard
Run length encoding is a very simple lossless compression algorithm which
 unfolds its full potential in sorted columns.
\end_layout

\begin_layout Standard
According to the approach published by Golomb 
\begin_inset CommandInset citation
LatexCommand cite
key "Golomb66"

\end_inset

, sequences of a value (socalled 
\begin_inset Quotes eld
\end_inset

runs
\begin_inset Quotes erd
\end_inset

) are replaced by a single occurence of this value and the length of the
 original sequence.
 Due to read performance losses, this method is not applicable for column
 stores in its original form, as all preceding values of a given index would
 have to be touched in order to find the actual value.
\end_layout

\begin_layout Standard
For this reason, the technique used in column stores is slightly different.
 To compress a column, all contiguous subsequent occurences of a value are
 removed from the index vector.
 Additionally, a second vector is generated.
 It contains the starting index of the index vectors corresponding entry.
 Thus, run length encoding reduces the size of a 
\emph on
sorted
\emph default
 column containing a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values to 
\begin_inset Formula 
\begin{equation}
d\cdot\lceil\log_{2}(d)\rceil+d\cdot\lceil\log_{2}(t)\rceil
\end{equation}

\end_inset

 bits.
 Furthermore, searching a given index becomes less complex compared to the
 original algorithm due to the modification mentioned above.
 For instance, it can be carried out in logarithmic time by binary search.
\end_layout

\begin_layout Subsection
[Anwendung auf Energiedaten]
\end_layout

\begin_layout Subsection
Estimation of Main Memory Consumption
\end_layout

\begin_layout Subsection
Impact on Insert Performance
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "thesis"
options "C:/Users/Leo/AppData/Roaming/MiKTeX/2.9/tex/latex/lncs/splncs03"

\end_inset


\end_layout

\end_body
\end_document
