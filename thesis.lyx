#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass llncs
\begin_preamble
\usepackage{graphicx}
\graphicspath{{.//}}
\end_preamble
\options final
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics pdftex
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Optimizing Storage of Energy Event Data in In-Memory Databases"
\pdf_author "Leonhard Schweizer"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Optimizing Storage of Energy Event Data in In-Memory Databases
\end_layout

\begin_layout Author
Leonhard Schweizer
\end_layout

\begin_layout Institute
Hasso Plattner Institute
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
email{leonhard.schweizer@student.hpi.uni-potsdam.de}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
In the course of the ongoing implementation of smart metering in Germany,
 residential customers alone will produce roughly 1.4 trillion records per
 year through their power meters.
 In other words, energy providers will have to deal with 1.4GB of raw data
 every 15 minutes, which is the default measurement interval of modern metering
 devices.
 The processing of continuous data streams of this dimension is a big challenge
 today and traditional OLAP systems aren't capable of analysing this huge
 amount of data in real-time.
 Thus, energy event data is sent to the providers at most once per day and
 analytical possibilities remain unused.
 By chosing an in-memory database as storage the data can be processed and
 analyzed simultaneously while notably reducing the amount of required space
 at the same time through the utilization of compression potentials in column-ba
sed tables.
 As a result, new opportunities arise, like offering electricity rates with
 real-time pricing or managing supply and demand based on up-to-the-minute
 analytics.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Not only the power market of Germany, but also those of other European countries
 are undergoing radical changes these days.
\end_layout

\begin_layout Standard
On the one hand, the growing importance of renewable and distributed energy
 sources like wind and solar energy as part of the aimed-at energy turnaround
 leads to an increased need of information.
 Despite their unpredictable nature, utility companies will depend on detailed
 insight into [large concentrated power plants, ATP]
\end_layout

\begin_layout Standard
On the other hand, the deregulation of markets forces suppliers of electric
 energy to offer competitive contract conditions and new tariff models to
 their customers.
 Amongst others, possibilities include contracts with very low or even no
 terms, encouraging the consumers to change their providers more frequently.
 On top of that, [RTP, TOUB]
\end_layout

\begin_layout Standard
[Daten von Smart Metern, Energieerzeugern]
\end_layout

\begin_layout Standard
[Herausforderungen: Verarbeitung, Speicherung, Analyse]
\end_layout

\begin_layout Standard
[Bogen schlagen zu In Memory, column stores]
\end_layout

\begin_layout Section
[AMI]
\end_layout

\begin_layout Subsection
[
\begin_inset Quotes eld
\end_inset

Tatsächliche
\begin_inset Quotes erd
\end_inset

 Architektur]
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/ami.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The Advanced Metering Infrastrucutre as depicted in 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/lcn/SchapranowKZP10"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
[Simulation -> 
\begin_inset Quotes eld
\end_inset

Implementation
\begin_inset Quotes erd
\end_inset

]
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/data-simulator.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Components of the AMI simulation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Insbesondere Abweichungen zu 2.1 (MDUS)
\end_layout

\begin_layout Itemize
Datenbank / Central System als Bottleneck -> Nur Betrachtung dessen in dieser
 Arbeit
\end_layout

\begin_layout Section
[(Insert) Performance]
\end_layout

\begin_layout Itemize
Was bringt Insert Only / Verzicht auf Keys, warum kein Problem
\end_layout

\begin_layout Itemize
Was bringt Verzicht auf Logs
\end_layout

\begin_layout Itemize
Was bringt Verzicht auf Autocommit
\end_layout

\begin_layout Itemize
Messbarer Unterschied Insert Float / Int?
\end_layout

\begin_layout Itemize
Select / Aggregation?
\end_layout

\begin_layout Section
Compression
\end_layout

\begin_layout Subsection
[Heavy -vs Lightweight?]
\end_layout

\begin_layout Subsection
Lightweight Column Compression Techniques
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Einteilung / Überblick, Verweis auf Bit Compression, Variable Byte Coding,
 PFOR -> nicht Gegenstand der Betrachtung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Domain Coding
\end_layout

\begin_layout Standard
Domain coding or dictionary compression is the fundamental compression algorithm
 which is utilized regardless of data types and structures and independently
 from other compression algorithms.
 All original values of a column are stored in a sorted dictionary and the
 column itself is represented as index vector consisting of ordinal references
 to this dictionary.
 Thus, a column containing 
\begin_inset Formula $d$
\end_inset

 distinct values of an arbitrary type and a total of 
\begin_inset Formula $t$
\end_inset

 values can be represented with 
\begin_inset Formula 
\begin{equation}
t\cdot\lceil\log_{2}(d)\rceil
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits optimally.
 The size of the dictionary itself has to be added to the total amount of
 required main memory, which carries weight especially when the record set
 contains a high percentage of distinct values.
 
\end_layout

\begin_layout Standard
Aside from the reduction of memory consumption, this method also entails
 an acceleration of processing speed due to the handling of smaller data
 volumes on a per request basis and the optimization of processing units
 for ordinal types on the hardware layer.
\end_layout

\begin_layout Subsubsection
Prefix Coding
\end_layout

\begin_layout Standard
Prefix coding is powerful in such cases where a column contains one specific
 value very often (e.g.
 the NULL-value) and the table can be sorted by this column such that this
 value occurs at the beginning of this column.
 The prefix of equal values is then removed from the index vector completely.
 The prefix value and the number of occurrences are saved separately, each
 with a consumption of 32 bits.
 A column with a total of 
\begin_inset Formula $t$
\end_inset

 elements, 
\begin_inset Formula $d$
\end_inset

 distinct values and a prefix of 
\begin_inset Formula $p$
\end_inset

 elements thus can be compressed to 
\begin_inset Formula 
\begin{equation}
(t-p)\cdot\lceil\log_{2}(d)\rceil+64
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
\end_layout

\begin_layout Subsubsection
Sparse Coding
\end_layout

\begin_layout Standard
If the occurences of the most frequent value are spread throughout a column,
 sparse coding can be used to reduce the size of this column.
 In doing so, all occurences of the value are removed from the index vector
 and this socalled sparse value is saved once as reference into the dictionary,
 consuming 32 bits.
 A bit vector is generated for the column, indicating whether the value
 corresponding to the element at the given index equals the sparse value
 or not.
 Thus, sparse compression reduces the size of a column with 
\begin_inset Formula $s$
\end_inset

 occurences of the sparse value to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
(t-s)\cdot\lceil\log_{2}(d)\rceil+t+32
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
 In addition, a prefix coding could be applied to the bit vector.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abweichung vom zitierten Paper!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To retrieve a value from a sparse encoded column, the bit vector has to
 be checked at the given index.
 If it indicates that the value differs from the sparse value, the index
 of the actual value within the index vector can be retrieved through the
 number of set bits up to the given index.
\end_layout

\begin_layout Subsubsection
Cluster Coding
\end_layout

\begin_layout Standard
When applying cluster coding, the index vector gets divided into equally
 sized blocks.
 All blocks which contain only one distinct value are then compressed by
 removing all but one occurence of the value within this block from the
 index vector.
 In addition, a bit vector is generated which indicates whether a block
 has been compressed or not.
 Therefore, cluster coding is applicable in cases where a column contains
 only few distinct values which form blocks innately.
 For instance, a column containing the alternating values 1, 2 and 3 would
 be the worst case for cluster coding.
 In the best case, a column with a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values could be compressed to 
\begin_inset Formula 
\begin{equation}
\frac{t}{b}\cdot\lceil\log_{2}(d)\rceil+\frac{t}{b}
\end{equation}

\end_inset

bits, where 
\begin_inset Formula $b$
\end_inset

 is the block size and 
\begin_inset Formula $b\mid t$
\end_inset

.
\end_layout

\begin_layout Standard
To retrieve the value of a given index 
\begin_inset Formula $i$
\end_inset

, the corresponding block has to be determined first by calculating 
\begin_inset Formula $\lfloor\frac{i}{b}\rfloor$
\end_inset

.
 The actual position within the index vector then can be determined by calculati
ng 
\begin_inset Formula $i-c\cdot(b-1)$
\end_inset

,
\begin_inset Note Note
status open

\begin_layout Plain Layout
Corner Cases überprüfen!
\end_layout

\end_inset

 where 
\begin_inset Formula $c$
\end_inset

 is the number of set bits in the bit vector up to the corresponding block.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Komplizierte Erklärung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Indirect Coding
\end_layout

\begin_layout Standard
Just like cluster coding, indirect coding is based on a division of the
 index vector into blocks of equal size.
 However, a domain coding of these blocks takes place.
 Thus, every block can have its own dictionary as additional level of indirectio
n between the actual value stored in the global dictionary and the bit vector
 pointing to this value from the index vector.
 Sharing dictionaries among subsequent blocks is possible as long as adding
 new values to the dictionary wouldn't increase the size of the bit vector
 representing the key.
 Furthermore, blocks with a high percentage of distinct values still can
 use the global dictionary directly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Datenstrukturen, Dekodierung?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Such beeing the case, indirect coding is particularly powerful in columns
 which contain blocks with few distinct values.
\end_layout

\begin_layout Subsubsection
Run Length Encoding
\end_layout

\begin_layout Standard
Run length encoding is a very simple lossless compression algorithm which
 unfolds its full potential in sorted columns.
\end_layout

\begin_layout Standard
According to the approach published by Golomb 
\begin_inset CommandInset citation
LatexCommand cite
key "Golomb66"

\end_inset

, sequences of a value (socalled 
\begin_inset Quotes eld
\end_inset

runs
\begin_inset Quotes erd
\end_inset

) are replaced by a single occurence of this value and the length of the
 original sequence.
 Due to read performance losses, this method is not applicable for column
 stores in its original form, as all preceding values of a given index would
 have to be touched in order to find the actual value.
\end_layout

\begin_layout Standard
For this reason, the technique used in column stores is slightly different.
 To compress a column, all contiguous subsequent occurences of a value are
 removed from the index vector.
 Additionally, a second vector is generated.
 It contains the starting index of the index vectors corresponding entry.
 Thus, run length encoding reduces the size of a 
\emph on
sorted
\emph default
 column containing a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values to 
\begin_inset Formula 
\begin{equation}
d\cdot\lceil\log_{2}(d)\rceil+d\cdot\lceil\log_{2}(t)\rceil
\end{equation}

\end_inset

 bits.
 Furthermore, searching a given index becomes less complex compared to the
 original algorithm due to the modification mentioned above.
 For instance, it can be carried out in logarithmic time by binary search.
\end_layout

\begin_layout Subsection
[Anwendung auf Energiedaten]
\end_layout

\begin_layout Subsection
Estimation of Main Memory Consumption
\end_layout

\begin_layout Subsection
Impact on Insert Performance
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "thesis"
options "C:/Users/Leo/AppData/Roaming/MiKTeX/2.9/tex/latex/lncs/splncs03"

\end_inset


\end_layout

\end_body
\end_document
