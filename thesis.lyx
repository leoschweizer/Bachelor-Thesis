#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass llncs
\begin_preamble
\usepackage{graphicx}
\graphicspath{{.//}}
\end_preamble
\options final
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics pdftex
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Optimizing Storage of Energy Event Data in In-Memory Databases"
\pdf_author "Leonhard Schweizer"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Optimizing Storage of Energy Event Data in In-Memory Databases
\end_layout

\begin_layout Author
Leonhard Schweizer
\end_layout

\begin_layout Institute
Hasso Plattner Institute
\begin_inset Newline newline
\end_inset

Chair Enterprise Platform and Integration Concepts
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
email{leonhard.schweizer@student.hpi.uni-potsdam.de}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
In the course of the ongoing implementation of smart metering in Germany,
 residential customers alone will produce roughly 1.4 trillion records per
 year through their power meters.
 In other words, energy providers will have to deal with 1.4GB of raw data
 every 15 minutes, which is the default measurement interval of modern metering
 devices.
 The processing of continuous data streams of this dimension is a big challenge
 today and traditional OLAP systems aren't capable of analysing this huge
 amount of data in real-time.
 Thus, energy event data is sent to the providers at most once per day and
 analytical possibilities remain unused.
 By chosing an in-memory database as storage the data can be processed and
 analyzed simultaneously while notably reducing the amount of required space
 at the same time through the utilization of compression potentials in column-ba
sed tables.
 As a result, new opportunities arise, like offering electricity rates with
 real-time pricing or managing supply and demand based on up-to-the-minute
 analytics.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Not only the power market of Germany, but also those of other European countries
 are undergoing radical changes these days.
\end_layout

\begin_layout Standard
On the one hand, the growing importance of renewable and distributed energy
 sources like wind and solar energy as part of the aimed-at energy turnaround
 leads to an increased need of information.
 Despite their unpredictable nature, utility companies will depend on detailed
 insight into [large concentrated power plants, ATP]
\end_layout

\begin_layout Standard
On the other hand, the deregulation of markets forces suppliers of electric
 energy to offer competitive contract conditions and new tariff models to
 their customers.
 Amongst others, possibilities include contracts with very low or even no
 terms, encouraging the consumers to change their providers more frequently.
 On top of that, [RTP, TOUB]
\end_layout

\begin_layout Standard
[Daten von Smart Metern, Energieerzeugern]
\end_layout

\begin_layout Standard
[Herausforderungen: Verarbeitung, Speicherung, Analyse]
\end_layout

\begin_layout Standard
[Bogen schlagen zu In Memory, column stores]
\end_layout

\begin_layout Section
[AMI und Simulation]
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:AMI"

\end_inset

[
\begin_inset Quotes eld
\end_inset

Tatsächliche
\begin_inset Quotes erd
\end_inset

 Architektur]
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/ami.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The Advanced Metering Infrastrucutre as depicted in 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/lcn/SchapranowKZP10"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
[Anforderungen an Simulation]
\end_layout

\begin_layout Standard
As an extensive rollout of smart metering devices and the corresponding
 metering infrastructure (cf.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:AMI"

\end_inset

) hasn't taken place yet in Germany, a simulation had to be used to generate
 a constant event stream of significant scale.
 Since the generated data should not only be used for stress testing, but
 also for real time analyses and visualization, various requirements had
 to be met by the simulation system.
\end_layout

\begin_layout Standard
The system had to be capable to simulate at least 100 million smart meters,
 each initiating one reading event per 15 minutes.
 Furthermore, the number of simulated metering devices should be freely
 configurable.
 On the one hand, the system thereby can be used to simulate divergent numbers
 of customers for energy providers of different size.
 On the other hand, the system can be used to simulate the projected total
 amount of events in the future smart grid of Germany.
\end_layout

\begin_layout Standard
In avoidance of unfavorable and advantageous effects of random data, for
 instance on compression rates, and with regard to data analysis and visualizati
on tests, the generated readings should be based on real power consumption
 data.
 Furthermore, the simulation should be aware of single customers.
 That means that for a given customer id, reading events should occur in
 15 minute intervals approximately.
 Besides, the unity of all readings of any simulated customer should form
 a realistic consumption behaviour over extended periods of time, e.g.
 days, weeks, months and years.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Bisher keine Rede von 
\begin_inset Quotes eld
\end_inset

customern
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
[Implementierung]
\end_layout

\begin_layout Standard
Our simulation of an Advanced Metering Infrastructure has been split up
 into three components, which are depicted in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulation"

\end_inset

.
 However, not all parts of the AMI have a counterpart in our simulation.
 Namely the Meter Data Unification and Synchronization (MDUS) system is
 missing, since there is no gain in simulating different vendor specific
 protocols and data formats.
 In the first place, the MDUS systems don't have to store data, in fact
 they transform it.
 That means that in order to scale, only the throughput has to be enhanced,
 which can be achieved easily by additional hardware and parallelisation.
 Therefore, the MDUS system should not constitue the AMIs limiting factor.
\end_layout

\begin_layout Standard
To a greater degree, the database which has to process, to store and to
 analyse all readings is the bottleneck of the whole system.
 At this point, scaling can not be reached simply by adding more hardware,
 in the sense of multiplying database hosts and instances.
 For example, all instances would have to be utilized for analytical queries
 like the overall consumption of all customers, with the effect that the
 partitioning of the data doesn't necessarily result in a lower overall
 load for each single instance.
\end_layout

\begin_layout Standard
Thus, the primary target of our simulation is the generation of huge amounts
 of insert load rather than a realistic representation of the AMI.
 In this way, the limits of an in-memory based central system can be investigate
d.
 All other components of the metering infrastructure can be scaled easily,
 which is the reason why this paper focuses on the performance of the database
 system itself.
\end_layout

\begin_layout Standard
In the following, the data producer, which constitutes the smart metering
 component of the AMI, the concentrator, which embodies the event aggregation
 component and the database client, which represents the interface of the
 industry-specific enterprise application are described in detail.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/data-simulator.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Simulation"

\end_inset

Components of the AMI simulation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Data-Producer"

\end_inset

Data Producer
\end_layout

\begin_layout Standard
An instance of the data producer, which is implemented as Java executable,
 represents any number of smart meters.
 One instance of the data producer can connect to exactly one concentrator
 (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Concentrator"

\end_inset

).
 A dedicated, persistent TCP/IP connection is built between the data producer
 and a concentrator for each thread the data producer is spawning.
 Thereby, one thread simulates up to XYZ smart meters.
 Thus, the number of smart meters that can be simulated by a single instance
 is mostly limited by the number of threads the host system is capable to
 handle and the network capacity.
\end_layout

\begin_layout Standard
The data producer expects two main input parameters: An initial timestamp,
 which defaults to the current local time, and a standard load profile,
 which defaults to the H0 profile published by the BDEW
\begin_inset Foot
status open

\begin_layout Plain Layout
German Energy and Water Association
\end_layout

\end_inset

.
 Such profiles contain the average consumption of a specific customer base
 (which are residential customers in the case of the H0 profile) over a
 period of one or more years.
 They consist of counter readings or consumption deltas in 15 minute intervals,
 yielding 35040 values for non-leapyears.
 For reasons depicted in Sect.
 4.3
\begin_inset Note Note
status open

\begin_layout Plain Layout
Querverweis!
\end_layout

\end_inset

, we prefer consumption deltas over counter readings.
\end_layout

\begin_layout Standard
Based on these two input parameters, readings are generated.
 The initial timestamp is used to calculate the current simulated day and
 time.
 After that, the according consumption value is read from the standard load
 profile.
 A random variance is added to this value 
\begin_inset Formula $v$
\end_inset

 for every generated reading 
\begin_inset Formula $r_{\mathrm{{v}}}$
\end_inset

 such that 
\begin_inset Formula $0\leq v-0,20\cdot v\leq r_{\mathrm{{v}}}\leq v+0,20\cdot v$
\end_inset

.
 Furthermore, the timestamp of the generated reading is rounded down to
 15 minute intervals.
 For instance, 13:14:55 would be replaced by 13:00:00 (cf.
 4.3
\begin_inset Note Note
status open

\begin_layout Plain Layout
Querverweis!
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
The third and last component of a reading is the unique integer device id
 by which every simulated smart meter can be identified.
 In our scenario, this device id is equivalent to a customer id, since relocatio
ns and the like aren't relevant for us.
\end_layout

\begin_layout Standard
The data producer generates discrete reading events for each of these identifier
s every 15 minutes and sends them to the assigned concentrator instantly.
 Thereby, the identifiers are spread randomly accross the 15 minute intervall,
 but keep their time slot across multiple intervals as long as the simulation
 is running.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

 shows one hour of readings for a given smart meter, starting at Sat, 28
 May 2011 20:00:00 GMT.
 During this hour, the household associated with the smart meter carrying
 the device id 32202775 had a total consumption of 0,143kWh.
\end_layout

\begin_layout Standard
Since we execute the simulation over an ethernet network via TCP/IP, data
 loss is of no concern.
 Thus, the push architecture described here could be favored over the pull
 approach which dominates in real world metering infrastructures.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Sample-readings"

\end_inset

Sample readings generated by the data producer
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle" tabularwidth="60col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Smart Meter ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value [Wh]
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306612800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306613700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306614600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306615500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Concentrator"

\end_inset

Concentrator
\end_layout

\begin_layout Standard
Just like the data producer, the concentrator is implemented as Java executable.
 Its purpose is to aggregate events and to forward these aggregated batches
 to a database client (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Database-Client"

\end_inset

), thus reducing the number of connections and insert events visible to
 the central database system.
\end_layout

\begin_layout Standard
A concentrator accepts any number of TCP/IP connections from any number
 of data producers (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-Producer"

\end_inset

).
 In turn, the concentrator can connect to one or more database clients,
 again via TCP/IP.
 The primary reason for supporting multiple database clients is the evaluation
 of distributed database systems, which is the subject of another thesis
\begin_inset Note Note
status open

\begin_layout Plain Layout
Verweis
\end_layout

\end_inset

.
 In this case, the concentrator is provided with the data partitioning instructi
ons and forwards the readings to the proper destination database instance.
\end_layout

\begin_layout Standard
The concentrator collects incoming readings until the batch size reaches
 a configurable threshold (default: 60000 readings) or the oldest reading
 in the batch exceeds a certain age (default: 5 minutes).
 Once this happens, the batch of readings gets converted into a column-wise
 fashion and is sent to the corresponding database client together with
 the number of readings contained in the batch.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Concentrator-Output"

\end_inset

 illustrates this conversion with the aid of the first two records of the
 row based data shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

.
 The resulting column based format is very beneficial for inserting data
 into column based tables.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/row-data.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/column-data.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Concentrator-Output"

\end_inset

The first two records from Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

 in row format and formated as output of a concentrator
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to the reasons outlined in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-Producer"

\end_inset

, the push approach could again be favored over a polling based architecture.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Database-Client"

\end_inset

Database Client
\end_layout

\begin_layout Standard
Of the three components depicted in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulation"

\end_inset

, the database client implements the least logic.
 The main purpose of this component is to expose a specialised interface
 for inserting batches of readings into the in-memory database, the back-end
 of our system.
\end_layout

\begin_layout Standard
It accepts TCP/IP connections from an arbitrary number of concentrators
 and inserts the incoming batches into the database in a non-blocking fashion.
 Thus, it can be avoided that the database client becomes the bottleneck
 of the system rather then the database itself.
 Since the concentrators already convert the readings into the desired format,
 no additional transformations of the data have to be carried out by the
 database client.
 The measures that have been taken to speed up the process of inserting
 as much as possible in order to reduce the overall load of the database
 and to enable the simultaneous processing of analytical requests are presented
 in Sect.
 3.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Querverweis!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to performance advantages of ODBC over JDBC, inserts are processed via
 the former, so this component of the simulation is implemented in C++ as
 native executable.
\end_layout

\begin_layout Subsection
Simulation Environment
\end_layout

\begin_layout Itemize
Hardware (DB, Producer)
\end_layout

\begin_layout Itemize
Topologie
\end_layout

\begin_layout Itemize
Schema, in das geinsertet wird
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Itemize
Last auf der Datenbank
\end_layout

\begin_layout Itemize
Inserzeit für Batches
\end_layout

\begin_layout Itemize
Jeweils mit unterschiedlichen Batchsizes
\end_layout

\begin_layout Section
[Optimizing (Insert) Performance]
\end_layout

\begin_layout Itemize
Messbarer Unterschied Insert Float / Int?
\end_layout

\begin_layout Subsection
[Prepared Statements / Batch Inserts] 
\end_layout

\begin_layout Subsection
Reducing Commit Frequency
\end_layout

\begin_layout Subsection
Omission of Natural Keys
\end_layout

\begin_layout Standard
When investigating the nature of a smart-meter reading, it becomes evident
 that the combination of its meter id and timestamp form a natural key that
 uniquely identifies each row.
 This key could very well serve as primary key for the table, as no two
 readings originating from the same meter may exist for a given point of
 time.
 However, this means that when inserting rows, time expensive tests on key
 violations would have to be performed.
 At the same time, there are no big drawbacks of allowing duplicate readings.
 Provided that meters normally don't record one point of time twice, saving
 such exceptional records might even be helpful for fraud and failure detection.
 Furthermore, keeping track of records might be a legal requirement in many
 countries.
\end_layout

\begin_layout Standard
The employed database system allows column tables without explicit primary
 key only in the form of socalled insert-only tables.
 As the name already suggests, records can only be added to a insert-only
 table, but neither be updated or deleted.
 These constraints can be accepted in our scenario, since concurrent readings
 could be distinguished by timestamps or valid/invalid-flags and there are
 no reasons for frequent updates.
 Insert-only tables make use of an implicit row id as primary key which
 is comparable to auto-increment fields.
 While increasing the consumed amount of memory through this additional
 column, a considerable reduction of insert times can be achieved through
 this approach.
\end_layout

\begin_layout Standard
To evaluate the benefits of insert-only tables, batches of 100,000 readings
 have been inserted into the tables shown in listing
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:TablesInsertOnly"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,float,language=SQL,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:TablesInsertOnly"

\end_inset

...
\end_layout

\end_inset

CREATE COLUMN TABLE readings1 (smartmeterid INTEGER, datetime INTEGER, value
 INTEGER, PRIMARY KEY (smartmeterid, datetime))
\end_layout

\begin_layout Plain Layout

CREATE INSERT ONLY COLUMN TABLE readings2 (smartmeterid INTEGER, datetime
 INTEGER, value INTEGER)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Comparison of insert-only and standard column tables in terms of insert
 performance
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Restraining Disaster Recovery
\end_layout

\begin_layout Standard
Transacation logs are an important measure to safeguard the compliance of
 the ACID properties, particularly with regard to atomicity and durability.
 However, one could imagine to give up parts of the ACID properties in exchange
 for performance benefits due to the supposed architecture of an advanced
 metering infrastructure.
 In particular, the ability to answer requests of meter readings on demand
 is ranked as minimum requirement for smart meters, which can store the
 reading history of at least one year at the same time.
 This implies that it might be feasible to accept the loss of recent meter
 readings in the case of a database failure, since they could just be requested
 again.
\end_layout

\begin_layout Standard
A column store consists of a read-optimized main store and a write-optimized
 differential buffer.
 New rows are inserted into the differential buffer and transfered to the
 main store during the socalled merge process.
 If strict ACID compliance is desired, both of these structures have to
 be recovered in the case of a failure.
 However, all records are written to a non-volatile medium during the merge
 process, which means that the persistency of the main store is not depending
 on transaction logs once the merge is complete.
 From this follows that logs are crucial during the merge process, since
 a failure during a merge could lead to an inconsistent persistency layer
 with far-reaching data losses.
 However, the impact of missing logs of the insert process itself is far
 less severe.
 In the worst case, all meter readings which haven't been merged yet would
 be lost temporarily.
\end_layout

\begin_layout Section
Compression
\end_layout

\begin_layout Subsection
[Heavy -vs Lightweight?]
\end_layout

\begin_layout Subsection
Lightweight Column Compression Techniques
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Einteilung / Überblick, Verweis auf Bit Compression, Variable Byte Coding,
 PFOR -> nicht Gegenstand der Betrachtung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Domain Coding
\end_layout

\begin_layout Standard
Domain coding or dictionary compression is the fundamental compression algorithm
 which is utilized regardless of data types and structures and independently
 from other compression algorithms.
 All original values of a column are stored in a sorted dictionary and the
 column itself is represented as index vector consisting of ordinal references
 to this dictionary.
 Thus, a column containing 
\begin_inset Formula $d$
\end_inset

 distinct values of an arbitrary type and a total of 
\begin_inset Formula $t$
\end_inset

 values can be represented with 
\begin_inset Formula 
\begin{equation}
t\cdot\lceil\log_{2}(d)\rceil
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits optimally.
 The size of the dictionary itself has to be added to the total amount of
 required main memory, which carries weight especially when the record set
 contains a high percentage of distinct values.
 
\end_layout

\begin_layout Standard
Aside from the reduction of memory consumption, this method also entails
 an acceleration of processing speed due to the handling of smaller data
 volumes on a per request basis and the optimization of processing units
 for ordinal types on the hardware layer.
\end_layout

\begin_layout Subsubsection
Prefix Coding
\end_layout

\begin_layout Standard
Prefix coding is powerful in such cases where a column contains one specific
 value very often (e.g.
 the NULL-value) and the table can be sorted by this column such that this
 value occurs at the beginning of this column.
 The prefix of equal values is then removed from the index vector completely.
 The prefix value and the number of occurrences are saved separately, each
 with a consumption of 32 bits.
 A column with a total of 
\begin_inset Formula $t$
\end_inset

 elements, 
\begin_inset Formula $d$
\end_inset

 distinct values and a prefix of 
\begin_inset Formula $p$
\end_inset

 elements thus can be compressed to 
\begin_inset Formula 
\begin{equation}
(t-p)\cdot\lceil\log_{2}(d)\rceil+64
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
\end_layout

\begin_layout Subsubsection
Sparse Coding
\end_layout

\begin_layout Standard
If the occurences of the most frequent value are spread throughout a column,
 sparse coding can be used to reduce the size of this column.
 In doing so, all occurences of the value are removed from the index vector
 and this socalled sparse value is saved once as reference into the dictionary,
 consuming 32 bits.
 A bit vector is generated for the column, indicating whether the value
 corresponding to the element at the given index equals the sparse value
 or not.
 Thus, sparse compression reduces the size of a column with 
\begin_inset Formula $s$
\end_inset

 occurences of the sparse value to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
(t-s)\cdot\lceil\log_{2}(d)\rceil+t+32
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
 In addition, a prefix coding could be applied to the bit vector.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Abweichung vom zitierten Paper!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To retrieve a value from a sparse encoded column, the bit vector has to
 be checked at the given index.
 If it indicates that the value differs from the sparse value, the index
 of the actual value within the index vector can be retrieved through the
 number of set bits up to the given index.
\end_layout

\begin_layout Subsubsection
Cluster Coding
\end_layout

\begin_layout Standard
When applying cluster coding, the index vector gets divided into equally
 sized blocks.
 All blocks which contain only one distinct value are then compressed by
 removing all but one occurence of the value within this block from the
 index vector.
 In addition, a bit vector is generated which indicates whether a block
 has been compressed or not.
 Therefore, cluster coding is applicable in cases where a column contains
 only few distinct values which form blocks innately.
 For instance, a column containing the alternating values 1, 2 and 3 would
 be the worst case for cluster coding.
 In the best case, a column with a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values could be compressed to 
\begin_inset Formula 
\begin{equation}
\frac{t}{b}\cdot\lceil\log_{2}(d)\rceil+\frac{t}{b}
\end{equation}

\end_inset

bits, where 
\begin_inset Formula $b$
\end_inset

 is the block size and 
\begin_inset Formula $b\mid t$
\end_inset

.
\end_layout

\begin_layout Standard
To retrieve the value of a given index 
\begin_inset Formula $i$
\end_inset

, the corresponding block has to be determined first by calculating 
\begin_inset Formula $\lfloor\frac{i}{b}\rfloor$
\end_inset

.
 The actual position within the index vector then can be determined by calculati
ng 
\begin_inset Formula $i-c\cdot(b-1)$
\end_inset

,
\begin_inset Note Note
status open

\begin_layout Plain Layout
Corner Cases überprüfen!
\end_layout

\end_inset

 where 
\begin_inset Formula $c$
\end_inset

 is the number of set bits in the bit vector up to the corresponding block.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Komplizierte Erklärung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Indirect Coding
\end_layout

\begin_layout Standard
Just like cluster coding, indirect coding is based on a division of the
 index vector into blocks of equal size.
 However, a domain coding of these blocks takes place.
 Thus, every block can have its own dictionary as additional level of indirectio
n between the actual value stored in the global dictionary and the bit vector
 pointing to this value from the index vector.
 Sharing dictionaries among subsequent blocks is possible as long as adding
 new values to the dictionary wouldn't increase the size of the bit vector
 representing the key.
 Furthermore, blocks with a high percentage of distinct values still can
 use the global dictionary directly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Datenstrukturen, Dekodierung?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Such beeing the case, indirect coding is particularly powerful in columns
 which contain blocks with few distinct values.
\end_layout

\begin_layout Subsubsection
Run Length Encoding
\end_layout

\begin_layout Standard
Run length encoding is a very simple lossless compression algorithm which
 unfolds its full potential in sorted columns.
\end_layout

\begin_layout Standard
According to the approach published by Golomb 
\begin_inset CommandInset citation
LatexCommand cite
key "Golomb66"

\end_inset

, sequences of a value (socalled 
\begin_inset Quotes eld
\end_inset

runs
\begin_inset Quotes erd
\end_inset

) are replaced by a single occurence of this value and the length of the
 original sequence.
 Due to read performance losses, this method is not applicable for column
 stores in its original form, as all preceding values of a given index would
 have to be touched in order to find the actual value.
\end_layout

\begin_layout Standard
For this reason, the technique used in column stores is slightly different.
 To compress a column, all contiguous subsequent occurences of a value are
 removed from the index vector.
 Additionally, a second vector is generated.
 It contains the starting index of the index vectors corresponding entry.
 Thus, run length encoding reduces the size of a 
\emph on
sorted
\emph default
 column containing a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values to 
\begin_inset Formula 
\begin{equation}
d\cdot\lceil\log_{2}(d)\rceil+d\cdot\lceil\log_{2}(t)\rceil
\end{equation}

\end_inset

 bits.
 Furthermore, searching a given index becomes less complex compared to the
 original algorithm due to the modification mentioned above.
 For instance, it can be carried out in logarithmic time by binary search.
\end_layout

\begin_layout Subsection
[Anwendung auf Energiedaten]
\end_layout

\begin_layout Subsection
Estimation of Main Memory Consumption
\end_layout

\begin_layout Standard
To estimate the main memory consumption of large customer bases, profiles
 containing one year of readings have been generated with the assistance
 of the H0-profile.
 Each profile consists of 35040 readings, and the value 
\begin_inset Formula $r_{\mathrm{v}}$
\end_inset

 of each reading differs from the equivalent value 
\begin_inset Formula $v$
\end_inset

 from the H0 profile randomly such that 
\begin_inset Formula $0\leq v-v\cdot0,20\leq r_{\mathrm{v}}\leq v+v\cdot0,20$
\end_inset

.
 The smart-meter ids have been chosen from 
\begin_inset Formula $[1,n]$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of generated profiles.
 However, the actual interval doesn't have a considerable effect on memory
 consumption due to the effects of dictionary compression.
 The year 2010 served as date range for the readings.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
RAM Consumption of sample readings (domain coding on all columns)
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="6">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0pt">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="right" valignment="top" width="0pt">
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Profiles
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RAM Consumption [MB]
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meter ID
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Row ID
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Total
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.002
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.17
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.29
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.04
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.92
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.92
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.41
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41.76
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29.24
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.20
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
584.83
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
292.40
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
79.37
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
RAM consumption of sample readings (domain coding on all columns, run length
 encoding on datetime-column)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="6">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0pt">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="decimal" decimal_point="." valignment="top" width="0">
<column alignment="right" valignment="top" width="0pt">
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Profiles
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RAM Consumption [MB]
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meter ID
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Row ID
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Total
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.27
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.002
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.31
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.17
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.28
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.29
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.04
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.78
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.92
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.29
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.92
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.41
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.54
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
41.76
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.31
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29.24
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.20
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
75.51
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10000
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
584.83
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.32
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
292.40
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
79.37
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
956.92
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Comparison of space requirements of compressed and uncompressed in-memory
 column tables and storage on hard disks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Profiles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size on Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uncompressed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Compressed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Optimum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10,000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6301.53
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
956.92
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100,000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,000,000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10,000,000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plots/consumption-estimation.eps
	width 75col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Estimation of main memory consumption for the given number of households
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Impact on Insert Performance
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "thesis"
options "C:/Users/Leo/AppData/Roaming/MiKTeX/2.9/tex/latex/lncs/splncs03"

\end_inset


\end_layout

\end_body
\end_document
