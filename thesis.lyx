#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass llncs
\begin_preamble
\usepackage{calc}
\usepackage{graphicx}
\graphicspath{{.//}}
\end_preamble
\options final
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics pdftex
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Optimizing Storage of Energy Event Data in In-Memory Databases"
\pdf_author "Leonhard Schweizer"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "numberbychapter=false"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\begin_layout Plain Layout


\backslash
thispagestyle{empty} 
\backslash
begin{center} 	
\backslash
vspace{0.1cm} 	
\backslash
LARGE 	Bachelor's Thesis
\backslash

\backslash
 	
\backslash
vspace{0.25cm} 	
\backslash
Huge 	Optimizing Storage of Energy Event Data in In-Memory Databases
\backslash

\backslash
 	
\backslash
vspace{0.5cm} 	
\backslash
large 	
\backslash
vspace{1.0cm} 	
\backslash
LARGE 	
\backslash
textbf{Leonhard Schweizer}
\backslash

\backslash
 	
\backslash
normalsize   leonhard.schweizer@student.hpi.uni-potsdam.de
\backslash

\backslash
 	
\backslash
vspace{0.5cm} 	
\backslash
small 	Hasso Plattner Institute for IT Systems Engineering
\backslash

\backslash
 	Enterprise Platform and Integration Concepts Chair
\backslash

\backslash
 	
\backslash
vspace{0.5cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename figures/hpi_logo.pdf

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.25cm}August-Bebel-Str.
 88
\backslash

\backslash
 	14482 Potsdam, Germany
\backslash

\backslash
 	
\backslash
url{http://epic.hpi.uni-potsdam.de/}
\backslash

\backslash
 	
\backslash
vspace{1.50cm}  Supervisors: 
\backslash
vspace{0.5cm}
\backslash

\backslash
  Dr.
 Alexander Zeier
\backslash

\backslash
Matthieu-P.
 Schapranow
\backslash

\backslash
 Christian Schwarz  
\backslash
vspace{0.5cm}
\backslash

\backslash
 Hasso Plattner Institute
\backslash

\backslash
 Potsdam, Germany  
\backslash
vspace{1.5cm}
\backslash

\backslash
 June 30th, 2011 
\backslash
end{center} 
\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Optimizing Storage of Energy Event Data in In-Memory Databases
\end_layout

\begin_layout Author
Leonhard Schweizer
\end_layout

\begin_layout Institute
Hasso Plattner Institute
\end_layout

\begin_layout Abstract
In the course of the ongoing implementation of smart metering in Germany,
 residential customers alone will produce roughly 1.4 trillion records per
 year through their power meters.
 In other words, energy providers will have to deal with 1.4GB of raw data
 every 15 minutes, which is the default measurement interval of modern metering
 devices.
 The processing of continuous data streams of this dimension is a big challenge
 today and traditional OLAP systems aren't capable of analysing this huge
 amount of data in real-time.
 Thus, energy event data is sent to the providers at most once per day and
 analytical possibilities remain unused.
 By chosing an in-memory database as storage the data can be processed and
 analyzed simultaneously while notably reducing the amount of required space
 at the same time through the utilization of compression potentials in column-ba
sed tables.
 As a result, new opportunities arise, like offering electricity rates with
 real-time pricing or managing supply and demand based on up-to-the-minute
 analytics.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Traditionally, database management systems are split into two categories
 
\begin_inset CommandInset citation
LatexCommand cite
key "journals/dbsk/KrugerGTEZP10"

\end_inset

.
 On the one hand, there are write-optimized, row oriented Online Transactional
 Processing (OLTP) systems, which in return lack analytical performance.
 On the other hand, there are read-optimized Online Analytical Processing
 (OLAP) systems, which aren't suitable for transactional processing.
 However, with the introduction of in-memory databases, the promise has
 been made that this separation becomes superfluous, in particular with
 the help of column oriented tables 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/sigmod/Plattner09"

\end_inset

 - a technique that was originally introduced as highly read-optimized approach
 by Stonebreaker et.
 al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Stonebraker:2005:CCD:1083592.1083658"

\end_inset

.
\end_layout

\begin_layout Standard
This raises the question to which extent in-memory databases can solve the
 challenges utility companies and energy providers throughout Europe will
 have to face in the near future.
 The growing importance of renewable and distributed energy sources like
 wind and solar energy as part of the aimed at energy turnaround leads to
 an increased need of information.
 
\end_layout

\begin_layout Standard
At the same time, suppliers of electric energy are forced to offer new contract
 conditions and tariff models to their customers.
\end_layout

\begin_layout Standard
While smart grid / smart meter [liefern daten], blabla...
 [kein System] enable involved parties [real-time informationsgewinnung].
\end_layout

\begin_layout Section
[AMI und Simulation]
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:AMI"

\end_inset

[
\begin_inset Quotes eld
\end_inset

Tats√§chliche
\begin_inset Quotes erd
\end_inset

 Architektur]
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/ami.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The Advanced Metering Infrastrucutre as depicted in 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/lcn/SchapranowKZP10"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
[Anforderungen an Simulation]
\end_layout

\begin_layout Standard
As an extensive rollout of smart metering devices and the corresponding
 metering infrastructure (cf.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:AMI"

\end_inset

) hasn't taken place yet in Germany, a simulation had to be used to generate
 a constant event stream of significant scale.
 Since the generated data should not only be used for stress testing, but
 also for real time analyses and visualization, various requirements had
 to be met by the simulation system.
\end_layout

\begin_layout Standard
The system had to be capable to simulate at least 100 million smart meters,
 each initiating one reading event per 15 minutes.
 Furthermore, the number of simulated metering devices should be freely
 configurable.
 On the one hand, the system thereby can be used to simulate divergent numbers
 of customers for energy providers of different size.
 On the other hand, the system can be used to simulate the projected total
 amount of events in the future smart grid of Germany.
\end_layout

\begin_layout Standard
In avoidance of unfavorable and advantageous effects of random data, for
 instance on compression rates, and with regard to data analysis and visualizati
on tests, the generated readings should be based on real power consumption
 data.
 Furthermore, the simulation should be aware of single smart meters.
 That means that for a given meter id, reading events should occur in 15
 minute intervals approximately.
 Besides, the unity of all readings of any simulated smart meter should
 form a realistic consumption behaviour over extended periods of time, e.g.
 days, weeks, months and years.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard
Our simulation of an Advanced Metering Infrastructure has been split up
 into three components, which are depicted in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulation"

\end_inset

.
 However, not all parts of the AMI have a counterpart in our simulation.
 Namely the Meter Data Unification and Synchronization (MDUS) system is
 missing, since there is no gain in simulating different vendor specific
 protocols and data formats.
 In the first place, the MDUS systems don't have to store data, in fact
 they transform it.
 That means that in order to scale, only the throughput has to be enhanced,
 which can be achieved easily by additional hardware and parallelisation.
 Therefore, the MDUS system should not constitue the AMIs limiting factor.
\end_layout

\begin_layout Standard
To a greater degree, the database which has to process, to store and to
 analyse all readings is the bottleneck of the whole system.
 At this point, scaling can not be reached simply by adding more hardware,
 in the sense of multiplying database hosts and instances.
 For example, all instances would have to be utilized for analytical queries
 like the overall consumption of all customers, with the effect that the
 partitioning of the data doesn't necessarily result in a lower overall
 load for each single instance.
\end_layout

\begin_layout Standard
Thus, the primary target of our simulation is the generation of huge amounts
 of insert load rather than a realistic representation of the AMI.
 In this way, the limits of an in-memory based central system can be investigate
d.
 All other components of the metering infrastructure can be scaled easily,
 which is the reason why this paper focuses on the performance of the database
 system itself.
\end_layout

\begin_layout Standard
In the following, the data producer, which constitutes the smart metering
 component of the AMI, the concentrator, which embodies the event aggregation
 component and the database client, which represents the interface of the
 industry-specific enterprise application are described in detail.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/data-simulator.svg
	width 90col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Simulation"

\end_inset

Components of the AMI simulation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Data-Producer"

\end_inset

Data Producer
\end_layout

\begin_layout Standard
An instance of the data producer, which is implemented as Java executable,
 represents any number of smart meters.
 One instance of the data producer can connect to exactly one concentrator
 (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Concentrator"

\end_inset

).
 A dedicated, persistent TCP/IP connection is built between the data producer
 and a concentrator for each thread the data producer is spawning.
 Thereby, one thread simulates up to XYZ
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zahl!!!
\end_layout

\end_inset

 smart meters.
 Thus, the number of smart meters that can be simulated by a single instance
 is mostly limited by the number of threads the host system is capable to
 handle and the network capacity.
\end_layout

\begin_layout Standard
The data producer expects two main input parameters: An initial timestamp,
 which defaults to the current local time, and a standard load profile,
 which defaults to the H0 profile published by the BDEW
\begin_inset Foot
status open

\begin_layout Plain Layout
German Energy and Water Association, www.bdew.de
\end_layout

\end_inset

.
 Such profiles contain the average consumption of a specific customer base
 (which are residential customers in the case of the H0 profile) over a
 period of one or more years.
 They consist of counter readings or consumption deltas in 15 minute intervals,
 yielding 35040 values for non-leapyears.
 For reasons depicted in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Compression-of-Energy"

\end_inset

, we prefer consumption deltas over counter readings.
\end_layout

\begin_layout Standard
Based on these two input parameters, readings are generated.
 The initial timestamp is used to calculate the current simulated day and
 time.
 After that, the according consumption value is read from the standard load
 profile.
 A random variance is added to this value 
\begin_inset Formula $v$
\end_inset

 for every generated reading 
\begin_inset Formula $r_{\mathrm{{v}}}$
\end_inset

 such that 
\begin_inset Formula $0\leq v-0,20\cdot v\leq r_{\mathrm{{v}}}\leq v+0,20\cdot v$
\end_inset

.
 Furthermore, the timestamp of the generated reading is rounded down to
 15 minute intervals.
 For instance, 13:14:55 would be replaced by 13:00:00 (cf.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Compression-of-Energy"

\end_inset

).
\end_layout

\begin_layout Standard
The third and last component of a reading is the unique integer device id
 by which every simulated smart meter can be identified.
 Each smart meter is associated with one customer, and each customer can
 have an arbitrary number of smart meters.
 However, this mapping information is not part of the table containing the
 meter readings.
\end_layout

\begin_layout Standard
The data producer generates discrete reading events for each of these identifier
s every 15 minutes and sends them to the assigned concentrator instantly.
 Thereby, the identifiers are spread randomly accross the 15 minute intervall,
 but keep their time slot across multiple intervals as long as the simulation
 is running.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

 shows one hour of readings for a given smart meter, starting at Sat, 28
 May 2011 20:00:00 GMT.
 During this hour, the household associated with the smart meter carrying
 the device id 32202775 had a total consumption of 0,143kWh.
\end_layout

\begin_layout Standard
Since we execute the simulation over an ethernet network via TCP/IP, data
 loss is of no concern.
 Thus, the push architecture described here could be favored over the pull
 approach which dominates in real world metering infrastructures.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Sample-readings"

\end_inset

Sample readings generated by the data producer
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle" tabularwidth="60col%">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row topspace="2mm" bottomspace="2mm">
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Smart Meter ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value [Wh]
\end_layout

\end_inset
</cell>
</row>
<row topspace="2mm" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306612800
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306613700
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
37
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306614600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32202775
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1306615500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
35
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Concentrator"

\end_inset

Concentrator
\end_layout

\begin_layout Standard
Just like the data producer, the concentrator is implemented as Java executable.
 Its purpose is to aggregate events and to forward these aggregated batches
 to a database client (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Database-Client"

\end_inset

), thus reducing the number of connections and insert events visible to
 the central database system.
\end_layout

\begin_layout Standard
A concentrator accepts any number of TCP/IP connections from any number
 of data producers (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-Producer"

\end_inset

).
 In turn, the concentrator can connect to one or more database clients,
 again via TCP/IP.
 The primary reason for supporting multiple database clients is the evaluation
 of distributed database systems, which is the subject of another thesis
 
\begin_inset CommandInset citation
LatexCommand cite
key "sten"

\end_inset

.
 In this case, the concentrator is provided with the data partitioning instructi
ons and forwards the readings to the proper destination database instance.
\end_layout

\begin_layout Standard
The concentrator collects incoming readings until the batch size reaches
 a configurable threshold (default: 60000 readings) or the oldest reading
 in the batch exceeds a certain age (default: 5 minutes).
 Once this happens, the batch of readings gets converted into a column-wise
 fashion and is sent to the corresponding database client together with
 the number of readings contained in the batch.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Concentrator-Output"

\end_inset

 illustrates this conversion with the aid of the first two records of the
 row based data shown in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

.
 The resulting column based format is very beneficial for inserting data
 into column based tables.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/row-data.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/column-data.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Concentrator-Output"

\end_inset

The first two records from Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

 in row format and formated as output of a concentrator
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to the reasons outlined in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-Producer"

\end_inset

, the push approach could again be favored over a polling based architecture.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Database-Client"

\end_inset

Database Client
\end_layout

\begin_layout Standard
Of the three components depicted in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulation"

\end_inset

, the database client implements the least logic.
 The main purpose of this component is to expose a specialised interface
 for inserting batches of readings into the in-memory database, the back-end
 of our system.
\end_layout

\begin_layout Standard
It accepts TCP/IP connections from an arbitrary number of concentrators
 and inserts the incoming batches into the database in a non-blocking fashion.
 Thus, it can be avoided that the database client becomes the bottleneck
 of the system rather then the database itself.
 Since the concentrators already convert the readings into the desired format,
 no additional transformations of the data have to be carried out by the
 database client.
 The measures that have been taken to speed up the process of inserting
 as much as possible in order to reduce the overall load of the database
 and to enable the simultaneous processing of analytical requests are presented
 in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Acceleration-of-INSERT"

\end_inset

.
\end_layout

\begin_layout Standard
Since the database client is intended for running on the same host as the
 database system, it is important to reduce the footprint of the client
 as far as possible.
 For that reason, the client is implemented as C++ native executable and
 connected to the database via ODBC.
 The C++ implementation reduces the main memory consumption from 
\begin_inset Formula $\approx2\mathrm{GB}$
\end_inset

 to 
\begin_inset Formula $<100\mathrm{MB}$
\end_inset

 compared to the analog Java implementation.
\end_layout

\begin_layout Subsection
Simulation Environment
\end_layout

\begin_layout Itemize
Hardware (DB, Producer)
\end_layout

\begin_layout Itemize
Topologie
\end_layout

\begin_layout Itemize
Schema, in das geinsertet wird
\end_layout

\begin_layout Subsection
Lessons Learned
\end_layout

\begin_layout Itemize
Last auf der Datenbank
\end_layout

\begin_layout Itemize
Inserzeit f√ºr Batches
\end_layout

\begin_layout Itemize
Merge-Problematik?
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Acceleration-of-INSERT"

\end_inset

Acceleration of INSERT-Statements
\end_layout

\begin_layout Standard
In order to support a constant data stream originating from as many smart
 meters as possible, it is important to reduce the execution time of INSERT-stat
ements to the greatest possible extent.
 The measures that have been taken into consideration for that reason are
 depicted and evaluated in this section.
\end_layout

\begin_layout Standard
Unless stated otherwise, all measurements in this section have been made
 under the following conditions: The database client is running on host
 HPC and connecting to a NewDB instance on host HPA via JDBC.
 The hosts are connected via Gigabit LAN.
 The execution of INSERT-statements takes place on empty tables, whereas
 each table is generated before and droped after each test run.
 Autocommit is disabled as well as automerge and merge times are not included
 in the measurements.
 Transactional logging isn't in effect during inserts.
 Time measurements are taken with the help of the Java getTimeInMillis()-API.
\end_layout

\begin_layout Standard
Three different schemas have been used for the measurements.
 The schema READINGS_PK (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Schema-READINGS_PK"

\end_inset

) constitutes a regular column table with a natural primary key on the columns
 meterid and datetime.
 The schema READINGS_IO_PK (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Schema-READINGS_IO_PK"

\end_inset

) is equivalent to READINGS_PK, except that it represents an insert-only
 column table.
 The third schema is READINGS_IO (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Schema-READINGS_IO"

\end_inset

), which is an insert-only column table with omitted explicit primary key.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,captionpos=b,float,frame=single,language=SQL,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Schema-READINGS_PK"

\end_inset

Schema READINGS_PK
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

CREATE COLUMN TABLE readings (meterid INTEGER, datetime INTEGER, value INTEGER,
 PRIMARY KEY (meterid, datetime))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,captionpos=b,float,frame=single,language=SQL,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Schema-READINGS_IO_PK"

\end_inset

Schema READINGS_IO_PK
\end_layout

\end_inset

CREATE INSERT ONLY COLUMN TABLE readings (meterid INTEGER, datetime INTEGER,
 value INTEGER, PRIMARY KEY (meterid, datetime))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,captionpos=b,float,frame=single,language=SQL,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Schema-READINGS_IO"

\end_inset

Schema READINGS_IO
\end_layout

\end_inset

CREATE INSERT ONLY COLUMN TABLE readings (meterid INTEGER, datetime INTEGER,
 value INTEGER)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Prepared-Statements"

\end_inset

Prepared Statements
\end_layout

\begin_layout Standard
The naive approach to insert multiple rows into a table is to execute single
 insert statements sequentially.
 The problem in doing so is that parsing and the generation of an execution
 plan is carried out again for each statement, although they are equivalent.
 The solution to this issue is the utilization of prepared statements.
 As its name implies, afore-mentioned tasks get executed only once and the
 statement can be reused for subsequent inserts.
 
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:naive-insert"

\end_inset

 compares the performance of the usage of standard and prepared statements.
 First, 100,000 readings have been inserted into an empty instance of READINGS_P
K by generating a new statement for each reading.
 After 10 runs, the total insert time averages 3 minutes 38.530 seconds (standard
 deviation: 3.281 seconds).
 When repeating the measurement using a prepared statement, the average
 insert time gets reduced to 51.974 seconds (standard deviation: 365ms),
 which is equivalent to a speed-up of almost 80%.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plots/naive-prepared.eps
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:naive-insert"

\end_inset

Comparison of standard and prepared statements
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Batch Inserts
\end_layout

\begin_layout Standard
As an extension of prepared statements, most database interfaces offer a
 possibility to execute batches of the same statement at once.
 The executeBatch method implemented by JDBC 
\begin_inset CommandInset citation
LatexCommand cite
key "java/statement"

\end_inset

 or the array binding capabilities offered by ODBC 
\begin_inset CommandInset citation
LatexCommand cite
key "msdn/arrayBinding"

\end_inset

 are examples for such functionality.
 
\end_layout

\begin_layout Standard
In contrast to the execution of 100,000 prepared, but discrete inserts (average:
 51.974 seconds, standard deviation: 365ms), the insert time can be further
 reduced to 646ms (standard deviation: 33ms) with the help of batch insert
 mechanisms, a speed-up of 99%.
 In the case of batch inserts, the measurement was determined through 1000
 runs and the measured time includes the generation and execution of a single
 prepared statement containing 100,000 rows, as well as a single commit
 at the end of the transaction.
 As with the measurement in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Prepared-Statements"

\end_inset

, an empty instance of READINGS_PK was used for every run.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plots/prepared-batch.eps
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Comparison of prepared statements and prepared batches
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Omission-of-Natural"

\end_inset

Omission of Natural Keys
\end_layout

\begin_layout Standard
When investigating the nature of a smart-meter reading, it becomes evident
 that the combination of its meter id and timestamp form a natural key that
 uniquely identifies each row.
 This key could very well serve as primary key for the table, as no two
 readings originating from the same meter may exist for a given point of
 time.
 However, this means that when inserting rows, time expensive tests on key
 violations would have to be performed.
 At the same time, there are no big drawbacks of allowing duplicate readings.
 Provided that meters normally don't record one point of time twice, saving
 such exceptional records might even be helpful for fraud and failure detection.
 Furthermore, keeping track of records might be a legal requirement in many
 countries 
\begin_inset CommandInset citation
LatexCommand cite
key "HPI/GrundKTZ/CeFda"

\end_inset

.
\end_layout

\begin_layout Standard
The employed database system allows column tables without explicit primary
 key only in the form of socalled insert-only tables.
 As the name already suggests, records can only be added to a insert-only
 table, but neither be updated or deleted.
 These constraints can be accepted in our scenario, since concurrent readings
 could be distinguished by timestamps or valid/invalid-flags and there are
 no reasons for frequent updates.
 Insert-only tables make use of an implicit row id as primary key which
 is comparable to auto-increment fields.
 While increasing the consumed amount of memory through this additional
 column, a considerable reduction of insert times can be achieved through
 this approach.
\end_layout

\begin_layout Standard
To evaluate the costs of explicit keys, batches of 100,000 readings have
 been inserted into the schemas READINGS_PK, READINGS_IO_PK and READINGS_IO.
 In each case, the measured time includes the generation of a prepared statement
 containing 100,000 rows, the execution of this statement on an empty table
 and a single commit at the end of this transaction.
 All three measurements have been repeated 1000 times.
\end_layout

\begin_layout Standard
The results are depicted in fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Insert-Only"

\end_inset

.
 Insertion into a regular column table with explicit primary key takes an
 average of 646ms (standard deviation: 33ms).
 Insert-only tables with an explicit primary key are only marginally faster,
 with an average of 612ms (standard deviation: 32ms).
 In contrast, insertions into a table without any explicit keys average
 166ms, with a standard deviation of 16ms.
 That means that insert times can be reduced by approximately 76% through
 the omission of unnecessary keys.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plots/insert-only.eps
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Insert-Only"

\end_inset

Comparison of insert performance of tables with and without explicit primary
 key
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Restraining Disaster Recovery
\end_layout

\begin_layout Standard
Transacation logs are an important measure to safeguard the compliance of
 the ACID properties, particularly with regard to atomicity and durability
 
\begin_inset CommandInset citation
LatexCommand cite
key "Haerder:1983:PTD:289.291"

\end_inset

.
 However, one could imagine to give up parts of the ACID properties in exchange
 for performance benefits due to the supposed architecture of an advanced
 metering infrastructure.
 In particular, the ability to answer requests of meter readings on demand
 is ranked as minimum requirement for smart meters 
\begin_inset CommandInset citation
LatexCommand cite
key "openmeter/requirements"

\end_inset

, which can store the reading history of at least one year at the same time.
 This implies that it might be feasible to accept the loss of recent meter
 readings in the case of a database failure, since they could just be requested
 again.
\end_layout

\begin_layout Standard
A column store consists of a read-optimized main store and a write-optimized
 differential buffer.
 New rows are inserted into the differential buffer and transfered to the
 main store during the socalled merge process 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:conf/dasfaa/KrugerGTPZF10"

\end_inset

.
 If strict ACID compliance is desired, both of these structures have to
 be recovered in the case of a failure.
 However, all records are written to a non-volatile medium during the merge
 process, which means that the persistency of the main store is not depending
 on transaction logs once the merge is complete.
 From this follows that logs are crucial during the merge process, since
 a failure during a merge could lead to an inconsistent persistency layer
 with far-reaching data losses.
 However, the impact of missing logs of the insert process itself is far
 less severe.
 In the worst case, all meter readings which haven't been merged yet would
 be lost temporarily.
\end_layout

\begin_layout Standard
The schema READINGS_IO was used to measure the impact of transaction logs
 on insert performance.
 Again, the measured time includes the generation of a prepared statement
 containing 100,000 rows, its execution on an empty table and a single commit
 at the end of this transaction.
 The measurement has been repeated 1000 times.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Logging"

\end_inset

 shows the results of this measurements.
 With activated logging, inserts average 177ms (standard deviation: 18ms).
 The same inserts take averagely 166ms (standard deviation: 16ms) when logging
 is disabled.
 In other words, transaction logs slow down the insert process by approximately
 6%.
 Thus, abandoning transaction logs for insertions can be considered doubtful
 for real world applications due to the comparatevely negligible impact.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plots/logging.eps
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Logging"

\end_inset

Impact of transactional logging on insert performance
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parallel Execution of INSERT-Statements
\end_layout

\begin_layout Standard
In order to allow for a better evaluation of the impact of parallel inserts,
 a bigger dataset of 1,000,000 rows has been inserted into the table READINGS_IO.
 The time measurement, which begins with the start of the first and ends
 with the return of the last spawned thread has been repeated 1000 times
 for 
\begin_inset Formula $2^{n}$
\end_inset

 threads, where 
\begin_inset Formula $n\in[1,6]$
\end_inset

.
 Thereby, the dataset is divided equally to all threads and each thread
 establishes a JDBC connection to the database and executes a single prepared
 insert statement containing 
\begin_inset Formula $\frac{1,000,000}{n}$
\end_inset

 rows.
 Every thread initiates a commit before returning, so the measured time
 includes 1 commit for 
\begin_inset Formula $n=1$
\end_inset

 and 64 commits for 
\begin_inset Formula $n=6$
\end_inset

.
 The server HPA, which hosts the database has a total of 12 cores with hyper-thr
eading, yielding 24 logical processors.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
nur 4 cores auf client rechner??
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results of the measurement are depicted in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:parallelisation"

\end_inset

.
 The insert time using one thread averages 
\begin_inset Formula $28.664$
\end_inset

 seconds, with a standard deviation of 
\begin_inset Formula $1304\mathrm{ms}$
\end_inset

.
 Based on this value, the theoretical optimum behaviour is plotted as 
\begin_inset Formula $\frac{v_{n-1}}{2}$
\end_inset

 for a number of 
\begin_inset Formula $n$
\end_inset

 threads and the projected time measurement 
\begin_inset Formula $v_{n-1}$
\end_inset

 of the preceding number of threads.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plots/parallel.eps
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:parallelisation"

\end_inset

Performance gain by parallel execution of INSERT-statements
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Compression
\end_layout

\begin_layout Subsection
[Heavy -vs Lightweight]
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Lightweight-Column-Compression"

\end_inset

Lightweight Column Compression Techniques
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Einteilung / √úberblick, Verweis auf Bit Compression, Variable Byte Coding,
 PFOR -> nicht Gegenstand der Betrachtung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Domain Coding
\end_layout

\begin_layout Standard
Domain coding or dictionary compression 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/btw/LemkeSF09,Abadi:2006:ICE:1142473.1142548,HPI/PlattnerZ/nHdai,Lemke:2010:SUQ:1881923.1881936"

\end_inset

 is the fundamental compression algorithm which is utilized regardless of
 data types and structures and independently from other compression algorithms.
 All original values of a column are stored in a sorted dictionary and the
 column itself is represented as index vector consisting of ordinal references
 to this dictionary.
 Thus, a column containing 
\begin_inset Formula $d$
\end_inset

 distinct values of an arbitrary type and a total of 
\begin_inset Formula $t$
\end_inset

 values can be represented with 
\begin_inset Formula 
\begin{equation}
t\cdot\lceil\log_{2}(d)\rceil\label{eq:domain-coding}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits optimally.
 The size of the dictionary itself has to be added to the total amount of
 required main memory, which carries weight especially when the record set
 contains a high percentage of distinct values.
 
\end_layout

\begin_layout Standard
Aside from the reduction of memory consumption, this method also entails
 an acceleration of processing speed due to the handling of smaller data
 volumes on a per request basis and the optimization of processing units
 for ordinal types on the hardware layer.
\end_layout

\begin_layout Subsubsection
Prefix Coding
\end_layout

\begin_layout Standard
Prefix coding 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/btw/LemkeSF09,HPI/PlattnerZ/nHdai,Lemke:2010:SUQ:1881923.1881936"

\end_inset

 is powerful in such cases where a column contains one specific value very
 often (e.g.
 the NULL-value) and the table can be sorted by this column such that this
 value occurs at the beginning of this column.
 The prefix of equal values is then removed from the index vector completely.
 The prefix value and the number of occurrences are saved separately, each
 with a consumption of 32 bits.
 A column with a total of 
\begin_inset Formula $t$
\end_inset

 elements, 
\begin_inset Formula $d$
\end_inset

 distinct values and a prefix of 
\begin_inset Formula $p$
\end_inset

 elements thus can be compressed to 
\begin_inset Formula 
\begin{equation}
(t-p)\cdot\lceil\log_{2}(d)\rceil+64
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
\end_layout

\begin_layout Subsubsection
Sparse Coding
\end_layout

\begin_layout Standard
If the occurences of the most frequent value are spread throughout a column,
 sparse coding 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/btw/LemkeSF09,HPI/PlattnerZ/nHdai,Lemke:2010:SUQ:1881923.1881936"

\end_inset

 can be used to reduce the size of this column.
 In doing so, all occurences of the value are removed from the index vector
 and this socalled sparse value is saved once as reference into the dictionary,
 consuming 32 bits.
 A bit vector is generated for the column, indicating whether the value
 corresponding to the element at the given index equals the sparse value
 or not.
 In addition, a prefix coding is applied to this bit vector.
 Thus, sparse compression reduces the size of a column with 
\begin_inset Formula $s$
\end_inset

 occurences of the sparse value to
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
(t-s)\cdot\lceil\log_{2}(d)\rceil+(t-p)+32
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
bits.
\end_layout

\begin_layout Standard
To retrieve a value from a sparse encoded column, the bit vector has to
 be checked at the given index.
 If it indicates that the value differs from the sparse value, the index
 of the actual value within the index vector can be retrieved through the
 number of set bits up to the given index.
\end_layout

\begin_layout Subsubsection
Cluster Coding
\end_layout

\begin_layout Standard
When applying cluster coding 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/btw/LemkeSF09,HPI/PlattnerZ/nHdai,Lemke:2010:SUQ:1881923.1881936"

\end_inset

, the index vector gets divided into equally sized blocks.
 All blocks which contain only one distinct value are then compressed by
 removing all but one occurence of the value within this block from the
 index vector.
 In addition, a bit vector is generated which indicates whether a block
 has been compressed or not.
 Therefore, cluster coding is applicable in cases where a column contains
 only few distinct values which form blocks innately.
 For instance, a column containing the alternating values 1, 2 and 3 would
 be the worst case for cluster coding.
 In the best case, a column with a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values could be compressed to 
\begin_inset Formula 
\begin{equation}
\frac{t}{b}\cdot\lceil\log_{2}(d)\rceil+\frac{t}{b}
\end{equation}

\end_inset

bits, where 
\begin_inset Formula $b$
\end_inset

 is the block size and 
\begin_inset Formula $b\mid t$
\end_inset

.
\end_layout

\begin_layout Standard
To retrieve the value of a given index 
\begin_inset Formula $i$
\end_inset

, the corresponding block has to be determined first by calculating 
\begin_inset Formula $\lfloor\frac{i}{b}\rfloor$
\end_inset

.
 The actual position within the index vector then can be determined by calculati
ng 
\begin_inset Formula $i-c\cdot(b-1)$
\end_inset

,
\begin_inset Note Note
status open

\begin_layout Plain Layout
Corner Cases √ºberpr√ºfen!
\end_layout

\end_inset

 where 
\begin_inset Formula $c$
\end_inset

 is the number of set bits in the bit vector up to the corresponding block.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Komplizierte Erkl√§rung
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Indirect Coding
\end_layout

\begin_layout Standard
Just like cluster coding, indirect coding 
\begin_inset CommandInset citation
LatexCommand cite
key "conf/btw/LemkeSF09,HPI/PlattnerZ/nHdai,Lemke:2010:SUQ:1881923.1881936"

\end_inset

 is based on a division of the index vector into blocks of equal size.
 However, a domain coding of these blocks takes place.
 Thus, every block can have its own dictionary as additional level of indirectio
n between the actual value stored in the global dictionary and the bit vector
 pointing to this value from the index vector.
 Sharing dictionaries among subsequent blocks is possible as long as adding
 new values to the dictionary wouldn't increase the size of the bit vector
 representing the key.
 Furthermore, blocks with a high percentage of distinct values still can
 use the global dictionary directly.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Datenstrukturen, Dekodierung?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Such beeing the case, indirect coding is particularly powerful in columns
 which contain blocks with few distinct values.
\end_layout

\begin_layout Subsubsection
Run Length Encoding
\end_layout

\begin_layout Standard
Run length encoding is a very simple lossless compression algorithm which
 unfolds its full potential in sorted columns.
\end_layout

\begin_layout Standard
According to the approach published by Golomb 
\begin_inset CommandInset citation
LatexCommand cite
key "Golomb66"

\end_inset

, sequences of a value (socalled 
\begin_inset Quotes eld
\end_inset

runs
\begin_inset Quotes erd
\end_inset

) are replaced by a single occurence of this value and the length of the
 original sequence.
 Due to read performance losses, this method is not applicable for column
 stores in its original form, as all preceding values of a given index would
 have to be touched in order to find the actual value.
\end_layout

\begin_layout Standard
For this reason, the technique used in column stores is slightly different
 
\begin_inset CommandInset citation
LatexCommand cite
key "HPI/PlattnerZ/nHdai"

\end_inset

.
 To compress a column, all contiguous subsequent occurences of a value are
 removed from the index vector.
 Additionally, a second vector is generated.
 It contains the starting index of the index vectors corresponding entry.
 Thus, run length encoding can reduce the size of a 
\emph on
sorted
\emph default
 column containing a total of 
\begin_inset Formula $t$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 distinct values to 
\begin_inset Formula 
\begin{equation}
d\cdot\lceil\log_{2}(d)\rceil+d\cdot\lceil\log_{2}(t)\rceil
\end{equation}

\end_inset

 bits.
 Furthermore, searching a given index becomes less complex compared to the
 original algorithm due to the modification mentioned above.
 For instance, it can be carried out in logarithmic time by binary search.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Compression-of-Energy"

\end_inset

Compression of Energy Event Data
\end_layout

\begin_layout Standard
With due regard to the available compression techniques outlined in sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Lightweight-Column-Compression"

\end_inset

, the process of minimizing the space requirements of smart-meter readings
 comes down to three tasks.
 First, the number of distinct values has to be reduced as far as possible
 without losing relevant information in order to unfold the full potential
 of dictionary compression.
 Secondly, the spreading of values has to be analyzed in order to evaluate
 potential benefits of common value suppression techniques.
 And in the third place, the readings have to be sorted in such a way that
 contiguous blocks of equal values which are as wide as possible occur.
 As mentioned in sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-Producer"

\end_inset

, the assumed model of meter readings consists of the three columns meter
 id, datetime and value.
\end_layout

\begin_layout Subsubsection
Reducing the Number of Distinct Values
\end_layout

\begin_layout Standard
When investigating the necessary number of distinct values, the meter id
 column can be ruled out quickly.
 Obviously, there have to be exactly as many distinct ids as there are smart-met
ers known to the system.
 Furthermore, the specific characteristics aren't an issue due to dictionary
 compression, so the natural implementation as integer in the interval 
\begin_inset Formula $[1,n[$
\end_inset

 can be chosen, where 
\begin_inset Formula $n$
\end_inset

 is the number of smart meters.
\end_layout

\begin_layout Standard
The situation is different with the datetime column.
 In a first approach, timestamps exact to the second have been used, yielding
 
\begin_inset Formula $365\cdot24\cdot60\cdot60=31,536,000$
\end_inset

 distinct values per year.
 But the necessity to save timestamps in such a high resolution is very
 questionable.
 The most relevant information for energy providers besides the consumption
 value is if there is a meter reading for a given time slot or not, and
 this information can be gained with far less accurate timestamps.
 Even real time analysis scenarios like the calculation of the current consumpti
on of all customers can be carried out without the need of timestamps exact
 to the second.
 In this specific example, it would be sufficient to build the sum of all
 known timestamps of a given time slot.
\end_layout

\begin_layout Standard
Hence, it is acceptable to reduce the resolution of the saved timestamps
 to the one of the measurement interval.
 This means that the timestamps can be rounded down to 15 minute intervals.
 For example, 08:21:30 can be replaced by 08:15:00.
 This strategy yields 
\begin_inset Formula $365\cdot24\cdot4=35,040$
\end_inset

 distinct values per year, which is a saving of 99.9% compared to the inital
 approach.
 In the abstract, the required amount of space could be reduced by truncating
 the timestamps.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Sample-readings"

\end_inset

 shows that at least the last two digits of a timestamp are always 
\begin_inset Formula $00$
\end_inset

, so stripping them would be a reversible operation.
 Through this procedure, 7 bits could be saved per timestamp.
 However, this means savings of no more than roughly 30KB per year since
 every value is saved in the dictionary only once, which isn't profitable.
\end_layout

\begin_layout Standard
The consumption information in the value column can be saved in two ways.
 One possibility is to save counter readings, that means every reading contains
 the total amount of consumed energy since the installation of the meter.
 The other possibility is to save consumption deltas.
 If the counter readings of two subsequent time slots are 
\begin_inset Formula $v_{t-1}$
\end_inset

 and 
\begin_inset Formula $v_{t}$
\end_inset

, the value that would be saved for the time slot 
\begin_inset Formula $t$
\end_inset

 would be 
\begin_inset Formula $v_{t}-v_{t-1}$
\end_inset

 in the case of consumption deltas.
 The two strategies are equivalent, as the sum of all deltas yields the
 counter reading, and the deltas can be calculated by subtracting subsequent
 counter readings.
 The question remains which approach requires less distinct values.
\end_layout

\begin_layout Standard
According to 
\begin_inset CommandInset citation
LatexCommand cite
key "eu/measurement"

\end_inset

, power meters are measuring kilowatt hours and are calibrated to three
 decimal places (watt hours).
 The consulting company Capgemini estimates a lifespan of eight years for
 smart-metering devices 
\begin_inset CommandInset citation
LatexCommand cite
key "capgemini/analyse"

\end_inset

.
 That means that residential customers with an average consumption of 1000kWh
 per year would produce around 
\begin_inset Formula $8\cdot1000\cdot1000=8,000,000$
\end_inset

 distinct counter readings over the period of a meters lifetime.
 
\end_layout

\begin_layout Standard
In analysing the H0 profile, which contains average consumption deltas of
 residential customers in 15 minute intervals, it can be determined that
 all values are in the interval of 
\begin_inset Formula $[0.001;0.067]$
\end_inset

 kWh.
 Since this profile is normalized to an annual consumption of 1000kWh, it
 can be compared directly to the calculation above.
 Even when taking huge deviations of the factor 100 or more into account,
 the number of distinct values is still only a fraction of those possible
 when saving counter readings.
 Therefore, it can be assumed that the number of distinct values can be
 reduced by 99.99% through the utilization of consumption deltas which thereby
 get the prefered option with regard to main memory consumption.
\end_layout

\begin_layout Subsubsection
Common Values
\end_layout

\begin_layout Standard
Since the meter id and datetime column contain values wich are rather distribute
d uniformly, the only column that could potentially benefit of common value
 suppression techniques is the value column.
 When taking the H0 profile as a basis, it turns out that some values indeed
 occur ten times more often than others.
 However, there is no single value which would qualify as universal most
 common value.
 Furthermore, it can be doubted that this phenomenon also becomes manifest
 in real consumption data since the profile is normalized.
 Accordingly, the common value suppression techniques prefix coding and
 sparse coding aren't practicable for energy event data.
\end_layout

\begin_layout Subsubsection
Finding the Optimal Ordering
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
jot}{3mm+3pt}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to achieve the highest possible compression, the table has to be
 sorted in a manner that continuous blocks of equal values are formed, preferebl
y in all columns.
 To evaluate the memory footprint of the meter readings table, the performance
 is measured as a function of the number of smart meters 
\begin_inset Formula $n$
\end_inset

, with every smart meter having a record set of one year in 15 minute intervals.
 In the following, the memory footprint of the table 
\begin_inset Formula $S_{\mathrm{total}}$
\end_inset

 is analyzed per column, so the total capacity requirements can be calculated
 by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
S_{\mathrm{total}}(n) & =S_{\mathrm{id}}(n)+S_{\mathrm{datetime}}(n)+S_{\mathrm{value}}(n)
\end{align}

\end_inset


\end_layout

\begin_layout Standard
which returns the minimum required number of bits for the chosen compression
 techniques.
 Thereby, the value column is assumed to contain at most 100 distinct values.
\end_layout

\begin_layout Standard
First of all, domain coding (cf.
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:domain-coding"

\end_inset

)) is applied to all columns.
 That means that there is a base compression on all columns which equals
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
S_{\mathrm{id}}(n) & =n\cdot35040\cdot\lceil\log_{2}(n)\rceil\label{eq:space-id}\\
S_{\mathrm{datetime}}(n) & =n\cdot35040\cdot\lceil\log_{2}(35040)\rceil\label{eq:space-datetime-1}\\
S_{\mathrm{value}}(n) & =n\cdot35040\cdot\lceil\log_{2}(100)\rceil\label{eq:space-value}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Nevertheless, the compression rate can be increased drastically by sorting
 and subsequent run length encoding.
 In the abstract, all three columns qualify for a primary sorting.
 The goal is to form as few continuous blocks as possible.
 Sorting the table by the meter id yields 
\begin_inset Formula $n$
\end_inset

 blocks with a length of 35040.
 If sorted by the datetime column, the result are 35040 blocks with each
 having a lenght of 
\begin_inset Formula $n$
\end_inset

.
 In comparison, there are only 100 blocks with an average length of 
\begin_inset Formula $\frac{n\cdot35040}{100}$
\end_inset

 when sorting the table by the value column.
 Hence, as run length encoding gets more and more inefficient when the number
 of blocks increases, the value column is theoretically best suited for
 a run length encoding.
\end_layout

\begin_layout Standard
However, one has to take into consideration that the domain coded datetime
 column requires more space than the domain coded value column, since 
\begin_inset Formula $\lceil\log_{2}(35040)\rceil>\lceil\log_{2}(100)\rceil$
\end_inset

.
 In other words, the datetime column consumes 
\begin_inset Formula $9\cdot n$
\end_inset

 more bits.
 This also applies to the meter id column for 
\begin_inset Formula $n>100$
\end_inset

.
 To solve the question if there are break-even points, the following auxiliary
 functions are used, where 
\begin_inset Formula $\mathrm{D}(n)$
\end_inset

 denotes the memory footprint of a domain coded column and 
\begin_inset Formula $\mathrm{RLE}(n)$
\end_inset

 the one of a run length encoded column for 
\begin_inset Formula $n$
\end_inset

 smart meters:
\begin_inset Formula 
\begin{align}
\mathrm{D}_{\mathrm{id}}(n) & =n\cdot35040\cdot\lceil\log_{2}(n)\rceil\\
\mathrm{RLE}_{\mathrm{id}}(n) & =n\cdot\lceil\log_{2}(n)\rceil+n\cdot\lceil\log_{2}(n\cdot35040)\rceil\\
\mathrm{D}_{\mathrm{datetime}}(n) & =n\cdot35040\cdot\lceil\log_{2}(35040)\rceil\\
\mathrm{RLE_{datetime}(n)} & =35040\cdot\lceil\log_{2}(35040)\rceil+35040\cdot\lceil\log_{2}(n\cdot35040)\rceil\\
\mathrm{D_{value}(n)} & =n\cdot35040\cdot\lceil\log_{2}(100)\rceil\\
\mathrm{RLE_{value}(n)} & =100\cdot\lceil\log_{2}(100)\rceil+100\cdot\lceil\log_{2}(n\cdot35040)\rceil
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The question is if there is a solution to the following inequation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mathrm{RLE_{value}}(n)+\mathrm{D_{datetime}}(n)\leq\mathrm{D_{value}}(n)+\mathrm{RLE_{datetime}}(n)
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It turns out that the inequation is only true for 
\begin_inset Formula $n\in[0,128]$
\end_inset

.
 For 
\begin_inset Formula $n>128$
\end_inset

, sorting the table by the datetime column has to be prefered.
 The same problem applies to the comparison of the meter id and datetime
 column.
 Again, the question is which solution is true for
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mathrm{RLE_{datetime}}(n)+\mathrm{D_{id}}(n)\leq\mathrm{D_{datetime}}(n)+\mathrm{RLE_{id}}(n)
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
This time, there is a break-even point at 
\begin_inset Formula $n=35040$
\end_inset

, or in other words the inequation is true for 
\begin_inset Formula $n\in[35040,\infty[$
\end_inset

.
 Hence, sorting by the datetime column is preferable as soon as more than
 35040 smart meters are in the database.
 Thus, function (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:space-datetime-1"

\end_inset

) can be replaced by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
S_{\mathrm{datetime}}(n)=35040\cdot\lceil\log_{2}(35040)\rceil+35040\cdot\lceil\log_{2}(n\cdot35040)\rceil
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Now that the primary sorting of the table is by datetime, no more compression
 techniques can be applied to the meter id column, since the number of distinct
 ids per datetime block equals the length of this block.
 However, this doesn't apply to the value column, which could be sorted
 within the constraints of the primary sorting.
 Since there is a correlation between date and time and energy consumption,
 it can even be assumed that certain values accumulate at a specific date
 and time, which would qualify the column for a further run length encoding.
 Since the column contains relatively few distinct values, applying an indirect
 coding and not sorting the column is conceivable as an alternative, too.
 As both scenarios can no longer be mapped reasonably as a function of the
 number of smart meters, the efficiency of both approaches has been evaluated
 experimentally.
\end_layout

\begin_layout Standard
In order to analyze the impact of both techniques, 10,000 profiles which
 conform to the conditions outlined in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Estimation-of-Consumption"

\end_inset

 have been inserted into the tables shown in listings 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Table-READINGS_RLE"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Table-READINGS_INDIRECT"

\end_inset

.
 The result is depicted in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:RLE-vs-INDIRECT"

\end_inset

.
 With 1,912KB compared to 187,101KB, the run length encoded column is almost
 100 times smaller than the one compressed with indirect coding.
 Consequently, the former is the prefered option for further compressing
 the table.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:RLE-vs-INDIRECT"

\end_inset

Compression rates and memory consumption of the value column with run length
 encoding and indirect coding
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row topspace="2mm" bottomspace="2mm">
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Table
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Compression Rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Consumption [KB]
\end_layout

\end_inset
</cell>
</row>
<row topspace="2mm" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
READINGS_RLE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99.9%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,912
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
READINGS_INDIRECT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86.3%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
187,101
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,captionpos=b,float,frame=single,language=SQL,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Table-READINGS_RLE"

\end_inset

Table READINGS_RLE
\end_layout

\end_inset

CREATE INSERT ONLY COLUMN TABLE readings (meterid INTEGER, datetime INTEGER,
 value INTEGER) WITH PARAMETERS ('COMPRESSION' = ('DATETIME', 'RLE'), 'COMPRESSI
ON' = ('VALUE', 'RLE'))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize\sffamily},breaklines=true,captionpos=b,float,frame=single,language=SQL,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Table-READINGS_INDIRECT"

\end_inset

Table READINGS_INDIRECT
\end_layout

\end_inset

CREATE INSERT ONLY COLUMN TABLE readings (meterid INTEGER, datetime INTEGER,
 value INTEGER) WITH PARAMETERS ('COMPRESSION' = ('DATETIME', 'RLE'), 'COMPRESSI
ON' = ('VALUE', 'INDIRECT'))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the worst case, the memory footprint of the value column hence can be
 calculated by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
S_{\mathrm{value}}(n)=35040\cdot100\cdot\lceil\log_{2}(100)\rceil+35040\cdot100\cdot\lceil\log_{2}(n\cdot35040)\rceil
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
which is still better than domain coding alone for 
\begin_inset Formula $n>442$
\end_inset

.
 The total amount of required memory thus can be estimated by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
S_{\mathrm{total}}(n) & =n\cdot35040\cdot\lceil\log_{2}(n)\rceil+\\
 & +35040\cdot\lceil\log_{2}(35040)\rceil+35040\cdot\lceil\log_{2}(n\cdot35040)\rceil+\nonumber \\
 & +35040\cdot100\cdot\lceil\log_{2}(100)\rceil+35040\cdot100\cdot\lceil\log_{2}(n\cdot35040)\rceil\nonumber 
\end{align}

\end_inset


\end_layout

\begin_layout Standard
However, 
\begin_inset Formula $S_{\mathrm{total}}$
\end_inset

 doesn't cover system overhead like the row-id column (cf.
 Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Omission-of-Natural"

\end_inset

).
 Therefore, the real consumption has been measured in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Estimation-of-Consumption"

\end_inset

 in order to give a more realistic estimation of the memory footprint of
 energy event data.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Estimation-of-Consumption"

\end_inset

Estimation of Main Memory Consumption
\end_layout

\begin_layout Standard
To estimate the main memory consumption of large customer bases, profiles
 containing one year of readings have been generated with the assistance
 of the H0-profile.
 Each profile consists of 35040 readings, and the value 
\begin_inset Formula $r_{\mathrm{v}}$
\end_inset

 of each reading differs from the equivalent value 
\begin_inset Formula $v$
\end_inset

 from the H0 profile randomly such that 
\begin_inset Formula $0\leq v-v\cdot0,20\leq r_{\mathrm{v}}\leq v+v\cdot0,20$
\end_inset

.
 The smart-meter ids have been chosen from 
\begin_inset Formula $[1,n]$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of generated profiles.
 However, the actual interval doesn't have a considerable effect on memory
 consumption due to the effects of dictionary compression.
 The year 2010 served as date range for the readings.
 
\end_layout

\begin_layout Standard
The profiles have been inserted and merged into the tables READINGS_IO and
 READINGS_RLE, so the measured memory footprint constitutes the size of
 the read-optimized main store.
 Since all rows have to be merged eventually to allow for real time analyses,
 the consumption behaviour of the main store is the one that matters.
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Footprint-IO"

\end_inset

 shows the memory footprint of the table READINGS_IO, which doesn't utilize
 any compression techniques besides domain coding.
 With the help of these measurements, the accuracy of the projection formula
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:domain-coding"

\end_inset

 for domain coded columns can be evaluated.
 The meter id column may server as an example.
 According to formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:domain-coding"

\end_inset

, it should require 584.80MB of main memory.
 The actual consumption differs from this value only by 30KB.
\end_layout

\begin_layout Standard
One can also see that the row id column, which is an implicit component
 of insert-only tables, is in no way optimized besides domain coding, since
 its footprint can be estimated very well by formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:domain-coding"

\end_inset

.
 The latter thus can be used to improve the projection of the total memory
 footprint of the table READINGS_IO for large 
\begin_inset Formula $n$
\end_inset

.
 Considering the already mentioned formulas 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:space-id"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:space-datetime-1"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:space-value"

\end_inset

, the footprint projection for the table READINGS_IO can be calculated by
 formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:readings_io"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
S_{\mathrm{total}}(n) & =n\cdot35040\cdot\lceil\log_{2}(n)\rceil+n\cdot35040\cdot\lceil\log_{2}(35040)\rceil\\
 & +n\cdot35040\cdot\lceil\log_{2}(100)\rceil+n\cdot35040\cdot\lceil\log_{2}(n\cdot35040)\rceil\nonumber 
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The memory footprint of the table READINGS_RLE, which applies a run-length
 encoding to the timestamp and value columns, is depicted in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Footprint-RLE"

\end_inset

.
 
\end_layout

\begin_layout Standard
In order to give a comparison of space requirements with disk-based storage,
 the same profiles which were inserted into the database were saved as comma
 separated values in plain text files (ASCII encoded, one byte per character).
 Since the timestamp has a fixed length and the values hava an average of
 two digits, each line consists of a fixed part which adds up to 15 bytes,
 including separators and line break.
 The other part is the meter id, whose length varies.
 Assumed that the meter id lies in the interval mentioned above, the size
 (in bits) of a file containing one year profiles of 
\begin_inset Formula $n$
\end_inset

 smart meters can be projected with formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:CSV-size"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
S_{\mathrm{csv}}(n)=n\cdot35040\cdot15\cdot8+{\displaystyle \sum_{k=2}^{n+1}}\lceil\log_{10}(k)\rceil\cdot35040\cdot8\label{eq:CSV-size}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
A comparison of the three storage modes domain coded table, run-length compresse
d table and disk storage in CSV format is given in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:footprint-estimation"

\end_inset

.
 While the values for 10,000 profiles are actual measurements, the others
 are projections with the help of the formulas [...].
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Footprint-IO"

\end_inset

Memory footprint of table READINGS_IO for a number of smart meters 
\begin_inset Formula $n$
\end_inset

, broken down by column, in [MB]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="6">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row topspace="2mm" bottomspace="2mm">
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n=1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $100$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10,000$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="3mm" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meter ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.004$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.17$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2.92$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $41.76$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $584.83$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.20$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.80$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6.82$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $66.97$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $668.45$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.03$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.29$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2.92$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $29.24$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $292.40$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="3mm">
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Row ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.07$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.84$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $9.61$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $112.79$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1290.84$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="3mm" bottomspace="default">
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.31$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2.10$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $22.28$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $250.78$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2836.53$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Footprint-RLE"

\end_inset

Memory footprint of table READINGS_RLE for a number of smart meters 
\begin_inset Formula $n$
\end_inset

, broken down by column, in [MB]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="6">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row topspace="2mm" bottomspace="2mm">
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n=1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $100$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10,000$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="3mm" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meter ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.004$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.17$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2.92$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $41.76$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $584.83$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.27$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.28$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.29$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.32$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.09$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.71$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1.47$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1.71$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1.87$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="3mm">
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Row ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.07$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.84$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $9.61$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $112.78$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1253.13$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="3mm" bottomspace="default">
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0.43$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2.00$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $14.30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $156.58$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1840.15$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:footprint-estimation"

\end_inset

Estimated space requirements of profiles containing one year of meter readings,
 on disk and in-memory
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle" tabularwidth="80col%">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row topspace="2mm" bottomspace="2mm">
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Profiles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size on Disk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uncompressed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Compressed
\end_layout

\end_inset
</cell>
</row>
<row topspace="2mm" bottomspace="2mm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx6.2\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx2.8\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx1.8\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $100,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx65\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx30\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx20\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1,000,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx682\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx345\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx230\mathrm{GB}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10,000,000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx7.0\mathrm{TB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx3.8\mathrm{TB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx2.5\mathrm{TB}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Impact-on-Insert"

\end_inset

Impact on Insert Performance
\end_layout

\begin_layout Standard
Graefe and Shapiro have shown that data compression can speed up operations
 rahter related to analytical queries 
\begin_inset CommandInset citation
LatexCommand cite
key "Graefe91datacompression"

\end_inset

.
 In contrast, it has to be assumed that compression does have a negative
 impact on inserts, or the merge process specifically.
 As compression isn't carried out on the write-optimized differential buffer,
 execution times of INSERT-statements aren't affected.
 However, a potentially expensive recompression has to be performed during
 each merge process.
\end_layout

\begin_layout Standard
In order to estimate the impact of the proposed compression strategy on
 the insert process, the execution time of the merge process has been measured
 for different base datasets.
 This base dataset, consisting of a number of profiles generated analogous
 to the ones in Sect.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Estimation-of-Consumption"

\end_inset

 is merged completely into the tables READINGS_IO and READINGS_RLE.
 Afterwards, another 100 profiles (3,504,000 rows) are inserted into the
 tables.
 Then, the time is measured it takes to merge the new records with the base
 dataset.
 The measurement was carried out on Host HPA and the database was configured
 to use at most four threads for the merge.
\end_layout

\begin_layout Standard
The results are depicted in Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:merge-comparison"

\end_inset

.
 In contrast to the assumption, it shows clearly that a run-length encoding
 on the columns datetime and value doesn't have a relevant impact on the
 merge process.
 One possible reason for this behaviour is that the compression overhead
 is compensated by the reduced data volume, which leads to a higher cache
 locality and reduced waiting time when reading data from main memory.
 
\end_layout

\begin_layout Standard
When merging with an empty table, the merge time averages 6033ms without
 run-length encoding (standard deviation: 54ms) and 6130ms (standard deviation:
 72ms) when applying this additional compression.
 If the table already contains 1000 profiles (350,40,000 rows), the merge
 takes an average of 3 minutes 15.680 seconds (standard deviation: 5.089 seconds)
 for the table READINGS_IO and 3 minutes 10.890 seconds (standard deviation:
 4.238 seconds) for the table READINGS_RLE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename plots/merge.eps
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:merge-comparison"

\end_inset

Comparison of merge durations for different schemas and base datasets
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Itemize
Insert-Rate prinzipiell machbar
\end_layout

\begin_layout Itemize
Tradeoff RowID - Insert-Performance
\end_layout

\begin_layout Itemize
Compression: kein Insert, aber gro√üer Platzvorteil
\end_layout

\begin_layout Itemize
Gro√ües Problem: merge-Verhalten (exponentielles Wachstum) -> Partitionierung,
 Aging
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Appendix
\end_layout

\begin_layout Subsection*
Benchmark Environment
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row topspace="2mm" bottomspace="2mm">
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size scriptsize
Host HPA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size scriptsize
Host HPB
\end_layout

\end_inset
</cell>
</row>
<row topspace="2mm" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
CPU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
2x Intel Xeon X5670 @ 2.93GHz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
4x Intel Xeon X7560 @ 2.27GHz
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Main Memory
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
144GB @ 800MHz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
256GB @ 1333MHz
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Operating System
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
openSUSE 11.2 2.6.31.14-0.8-desktop (x64)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Network Connectivity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
82575EB Gigabit LAN
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
NX3031 10-Gigabit LAN
\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
NewDB Version
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
1.50.327452 (dbg)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="2mm">
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="2mm" bottomspace="2mm">
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size scriptsize
Host HPC
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="2mm" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
CPU
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Intel Core i5 750 @ 2.67GHz
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Main Memory
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
8GB @ 1333MHz
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Operating System
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
openSUSE 11.3 2.6.34.8-0.2-desktop (x64)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row topspace="default" bottomspace="default">
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Network Connectivity
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
82578DM Gigabit LAN
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesis"
options "C:/Users/Leo/AppData/Roaming/MiKTeX/2.9/tex/latex/lncs/splncs03"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty} 
\backslash
chapter*{Eigenst
\backslash
"andigkeitserkl
\backslash
"arung}
\end_layout

\begin_layout Plain Layout

Ich erkl
\backslash
"are hiermit, dass ich die vorliegende Arbeit selbst
\backslash
"andig verfasst und  keine anderen als die genannten Quellen und Hilfsmittel
 verwendet habe.
\backslash

\backslash
 
\backslash
vspace{2.0cm}
\backslash

\backslash
 Potsdam, den 30.
 Juni 2011 
\backslash
vspace{1.0cm}
\backslash

\backslash
 Leonhard Schweizer
\end_layout

\end_inset


\end_layout

\end_body
\end_document
